/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
__export(exports, {
  DEFAULT_SETTINGS: () => DEFAULT_SETTINGS,
  FILE_TITLE_BACKGROUND_COLOR: () => FILE_TITLE_BACKGROUND_COLOR,
  FILE_TITLE_BACKGROUND_COLOR_HOVER: () => FILE_TITLE_BACKGROUND_COLOR_HOVER,
  LIST_CALLOUT_DEFAULT: () => LIST_CALLOUT_DEFAULT,
  default: () => MultipleNotesOutlinePlugin3
});
var import_obsidian13 = __toModule(require("obsidian"));

// src/fileView.ts
var import_obsidian8 = __toModule(require("obsidian"));
var import_obsidian9 = __toModule(require("obsidian"));

// src/getTargetFiles.ts
var import_obsidian = __toModule(require("obsidian"));
function getOutgoingLinkFiles(app2, file, info, cache) {
  var _a;
  const files = [];
  for (let i = 0; i < ((_a = info == null ? void 0 : info.frontmatterLinks) == null ? void 0 : _a.length); i++) {
    const fileobj = app2.metadataCache.getFirstLinkpathDest(info.frontmatterLinks[i].link, file.path);
    if (fileobj instanceof import_obsidian.TFile) {
      files.push(fileobj);
    }
  }
  for (let i = 0; i < (cache == null ? void 0 : cache.length); i++) {
    if (cache[i].typeOfElement != "link") {
      continue;
    }
    const fileobj = app2.metadataCache.getFirstLinkpathDest(cache[i].link, file.path);
    if (fileobj instanceof import_obsidian.TFile) {
      files.push(fileobj);
    }
  }
  return files;
}
function getBacklinkFiles(app2, file) {
  const files = [];
  const backlinks = app2.metadataCache.getBacklinksForFile(file).data;
  for (const key in backlinks) {
    const fileobj = app2.vault.getAbstractFileByPath(key);
    if (fileobj instanceof import_obsidian.TFile) {
      files.push(fileobj);
    }
  }
  return files;
}
function getBacklinkFilesDataview(app2, file, isDataviewEnabled) {
  var _a, _b, _c, _d;
  const files = [];
  if (!isDataviewEnabled) {
    return getBacklinkFiles(app2, file);
  }
  const backlinks = (_d = (_c = (_b = (_a = app2.plugins.plugins.dataview) == null ? void 0 : _a.api) == null ? void 0 : _b.pages(`"${file.path}"`)) == null ? void 0 : _c.values[0]) == null ? void 0 : _d.file.inlinks.values;
  if (!backlinks) {
    return getBacklinkFiles(app2, file);
  }
  for (let i = 0; i < backlinks.length; i++) {
    const fileobj = app2.vault.getAbstractFileByPath(backlinks[i].path);
    if (fileobj instanceof import_obsidian.TFile) {
      files.push(fileobj);
    }
  }
  return files;
}

// src/getOutline.ts
var import_obsidian2 = __toModule(require("obsidian"));
function initFileStatus(files) {
  const status = [];
  for (let i = 0; i < files.length; i++) {
    const flagFolder = Boolean(files[i] instanceof import_obsidian2.TFolder);
    status.push({
      isFolded: false,
      isTop: false,
      duplicated: {
        main: false,
        outgoing: false,
        backlink: false,
        self: false
      },
      outlineReady: false,
      isFolder: flagFolder
    });
  }
  return status;
}
function getFileInfo(app2, file, settings, forceGetBacklinks = false, isDataviewEnabled) {
  return __async(this, null, function* () {
    if (file.extension == "md") {
      const content = yield this.app.vault.cachedRead(file);
      const lines = content.split("\n");
      const backlinkFiles = settings.showBacklinks || forceGetBacklinks ? getBacklinkFilesDataview(app2, file, isDataviewEnabled) : void 0;
      const info = {
        lines,
        numOfLines: lines.length,
        backlinks: backlinkFiles,
        frontmatterLinks: void 0
      };
      return info;
    } else {
      const backlinkFiles = settings.showBacklinks || forceGetBacklinks ? getBacklinkFilesDataview(app2, file, isDataviewEnabled) : void 0;
      const info = {
        lines: [""],
        numOfLines: 0,
        backlinks: backlinkFiles,
        frontmatterLinks: void 0
      };
      return info;
    }
  });
}
function getOutline(app2, file, status, info, settings) {
  return __async(this, null, function* () {
    const data = [];
    const cache = app2.metadataCache.getFileCache(file);
    if (file.extension == "canvas") {
      return yield getCanvasOutline(app2, file);
    }
    if (file.extension != "md") {
      return data;
    }
    if (!cache) {
      return null;
    }
    info.frontmatterLinks = cache == null ? void 0 : cache.frontmatterLinks;
    if (cache.hasOwnProperty("headings")) {
      for (let j = 0; j < cache.headings.length; j++) {
        const element = {
          typeOfElement: "heading",
          position: cache.headings[j].position,
          displayText: cache.headings[j].heading,
          level: cache.headings[j].level
        };
        data.push(element);
      }
    }
    if (cache.hasOwnProperty("links")) {
      for (let j = 0; j < cache.links.length; j++) {
        const element = {
          typeOfElement: "link",
          position: cache.links[j].position,
          displayText: cache.links[j].displayText == "" ? cache.links[j].original.substring(1, cache.links[j].original.indexOf("]")) : cache.links[j].displayText,
          link: cache.links[j].link
        };
        data.push(element);
      }
    }
    if (cache.hasOwnProperty("embeds")) {
      for (let j = 0; j < cache.embeds.length; j++) {
        const element = {
          typeOfElement: "link",
          position: cache.embeds[j].position,
          displayText: cache.embeds[j].displayText == "" ? cache.embeds[j].original.substring(1, cache.embeds[j].original.indexOf("]")) : cache.embeds[j].displayText,
          link: cache.embeds[j].link
        };
        data.push(element);
      }
    }
    if (cache.hasOwnProperty("listItems")) {
      for (let j = 0; j < cache.listItems.length; j++) {
        let listLevel = 0;
        if (cache.listItems[j].parent > 0) {
          listLevel = 2;
        } else if (j > 0) {
          if (!(Math.abs(cache.listItems[j].parent) == cache.listItems[j].position.start.line) && cache.listItems[j].position.start.line - cache.listItems[j - 1].position.start.line == 1) {
            listLevel = 1;
          }
        }
        const element = {
          typeOfElement: "listItems",
          position: cache.listItems[j].position,
          displayText: info == null ? void 0 : info.lines[cache.listItems[j].position.start.line].replace(/^(\s|\t)*-\s(\[.+\]\s)*/, ""),
          level: listLevel,
          task: cache.listItems[j].task
        };
        data.push(element);
      }
    }
    if (cache.hasOwnProperty("tags")) {
      for (let j = 0; j < cache.tags.length; j++) {
        const element = {
          typeOfElement: "tag",
          position: cache.tags[j].position,
          displayText: cache.tags[j].tag.substring(1)
        };
        data.push(element);
        for (const value of settings.tagsAOT) {
          if (value && cache.tags[j].tag == value) {
            status.isTop = true;
          }
        }
      }
    }
    data.sort((a, b) => {
      return a.position.start.offset - b.position.start.offset;
    });
    return data;
  });
}
function getCanvasOutline(app2, file) {
  return __async(this, null, function* () {
    const data = [];
    const canvas = yield app2.vault.read(file);
    const canvasData = JSON.parse(canvas);
    if (!(canvasData == null ? void 0 : canvasData.nodes)) {
      return data;
    }
    for (const node of canvasData.nodes) {
      if (node.type == "file") {
        const element = {
          typeOfElement: "link",
          position: void 0,
          displayText: app2.vault.getAbstractFileByPath(node.file).name,
          link: app2.vault.getAbstractFileByPath(node.file).name
        };
        data.push(element);
      }
      if (node.type == "text") {
        const element = {
          typeOfElement: "listItems",
          position: void 0,
          displayText: node.text,
          level: 0,
          task: void 0
        };
        data.push(element);
      }
    }
    data.sort((a, b) => {
      if (a.typeOfElement != b.typeOfElement) {
        return a.typeOfElement == "link" ? -1 : 1;
      }
      return a.displayText < b.displayText ? -1 : 1;
    });
    return data;
  });
}

// src/util.ts
var import_obsidian3 = __toModule(require("obsidian"));
function cleanRelatedFiles(srcFile, dstFile, settings) {
  if (Object.keys(settings.relatedFiles[srcFile.path][dstFile.path]).length == 0) {
    delete settings.relatedFiles[srcFile.path][dstFile.path];
  }
  if (Object.keys(settings.relatedFiles[srcFile.path]).length === 0) {
    delete settings.relatedFiles[srcFile.path];
  }
}
function checkFlag(srcFile, dstFile, flag, settings) {
  var _a, _b;
  return (_b = (_a = settings.relatedFiles[srcFile.path]) == null ? void 0 : _a[dstFile.path]) == null ? void 0 : _b[flag];
}
function addFlag(srcFile, dstFile, flag, settings) {
  if (!settings.relatedFiles.hasOwnProperty(srcFile.path)) {
    settings.relatedFiles[srcFile.path] = {};
  }
  if (!settings.relatedFiles[srcFile.path].hasOwnProperty(dstFile.path)) {
    settings.relatedFiles[srcFile.path][dstFile.path] = {};
  }
  settings.relatedFiles[srcFile.path][dstFile.path][flag] = true;
}
function removeFlag(srcFile, dstFile, flag, settings) {
  delete settings.relatedFiles[srcFile.path][dstFile.path][flag];
  cleanRelatedFiles(srcFile, dstFile, settings);
}
function handleRenameRelatedFiles(renamedFile, oldPath, settings) {
  let renamed = false;
  for (const srcFilePath in settings.relatedFiles) {
    for (const dstFilePath in settings.relatedFiles[srcFilePath]) {
      if (dstFilePath == oldPath) {
        settings.relatedFiles[srcFilePath][renamedFile.path] = settings.relatedFiles[srcFilePath][dstFilePath];
        delete settings.relatedFiles[srcFilePath][dstFilePath];
        renamed = true;
      }
    }
    if (srcFilePath == oldPath) {
      settings.relatedFiles[renamedFile.path] = settings.relatedFiles[srcFilePath];
      delete settings.relatedFiles[srcFilePath];
      renamed = true;
    }
  }
  return renamed;
}
function handleDeleteRelatedFiles(deletedFile, settings) {
  let deleted = false;
  for (const srcFilePath in settings.relatedFiles) {
    for (const dstFilePath in settings.relatedFiles[srcFilePath]) {
      if (dstFilePath == deletedFile.path) {
        delete settings.relatedFiles[srcFilePath][dstFilePath];
        deleted = true;
      }
    }
    if (srcFilePath == deletedFile.path) {
      delete settings.relatedFiles[srcFilePath];
      deleted = true;
    }
  }
  return deleted;
}
function getTheme() {
  var _a;
  const theme = ((_a = app.vault.config) == null ? void 0 : _a.theme) === "moonstone" ? "light" : "dark";
  return theme;
}
function setNoteTitleBackgroundColor(theme, settings) {
  switch (settings.noteTitleBackgroundColor) {
    case "none":
      break;
    case "custom":
      document.getElementsByTagName("body")[0].style.setProperty("--MNO-filetitle-background", settings.customNoteTitleBackgroundColor[theme]);
      document.getElementsByTagName("body")[0].style.setProperty("--MNO-filetitle-background-hover", settings.customNoteTitleBackgroundColorHover[theme]);
      break;
    default:
      document.getElementsByTagName("body")[0].style.setProperty("--MNO-filetitle-background", FILE_TITLE_BACKGROUND_COLOR[settings.noteTitleBackgroundColor][theme]);
      document.getElementsByTagName("body")[0].style.setProperty("--MNO-filetitle-background-hover", FILE_TITLE_BACKGROUND_COLOR_HOVER[settings.noteTitleBackgroundColor][theme]);
      break;
  }
}
function sortFileOrder(order, files, status, info, settings) {
  switch (settings.sortType) {
    case "alphabetAscending":
      order.sort((val1, val2) => {
        if (status[val1].isFolder != status[val2].isFolder) {
          return status[val1].isFolder == true ? 1 : -1;
        }
        return files[val1].name.localeCompare(files[val2].name);
      });
      break;
    case "alphabetDescending":
      order.sort((val1, val2) => {
        if (status[val1].isFolder != status[val2].isFolder) {
          return status[val1].isFolder == true ? 1 : -1;
        }
        return files[val2].name.localeCompare(files[val1].name);
      });
      break;
    case "ctimeDescending":
      order.sort((val1, val2) => {
        var _a, _b;
        if (status[val1].isFolder != status[val2].isFolder) {
          return status[val1].isFolder == true ? 1 : -1;
        }
        if (status[val1].isFolder == true) {
          return files[val1].name.localeCompare(files[val2].name);
        }
        return ((_a = files[val2]) == null ? void 0 : _a.stat.ctime) - ((_b = files[val1]) == null ? void 0 : _b.stat.ctime);
      });
      break;
    case "ctimeAscending":
      order.sort((val1, val2) => {
        var _a, _b;
        if (status[val1].isFolder != status[val2].isFolder) {
          return status[val1].isFolder == true ? 1 : -1;
        }
        if (status[val1].isFolder == true) {
          return files[val1].name.localeCompare(files[val2].name);
        }
        return ((_a = files[val1]) == null ? void 0 : _a.stat.ctime) - ((_b = files[val2]) == null ? void 0 : _b.stat.ctime);
      });
      break;
    case "mtimeDescending":
      order.sort((val1, val2) => {
        if (status[val1].isFolder != status[val2].isFolder) {
          return status[val1].isFolder == true ? 1 : -1;
        }
        if (status[val1].isFolder == true) {
          return files[val1].name.localeCompare(files[val2].name);
        }
        return files[val2].stat.mtime - files[val1].stat.mtime;
      });
      break;
    case "mtimeAscending":
      order.sort((val1, val2) => {
        if (status[val1].isFolder != status[val2].isFolder) {
          return status[val1].isFolder == true ? 1 : -1;
        }
        if (status[val1].isFolder == true) {
          return files[val1].name.localeCompare(files[val2].name);
        }
        return files[val1].stat.mtime - files[val2].stat.mtime;
      });
      break;
    default:
      break;
  }
}
var ModalConfirm = class extends import_obsidian3.Modal {
  constructor(app2, plugin, instruction, onSubmit) {
    super(app2);
    this.plugin = plugin;
    this.instruction = instruction;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("br");
    contentEl.createEl("p", {
      text: this.instruction
    });
    new import_obsidian3.Setting(contentEl).addButton((btn) => btn.setButtonText("Execute").setCta().onClick(() => __async(this, null, function* () {
      this.execute();
    }))).addButton((btn) => btn.setButtonText("Cancel").onClick(() => {
      this.close();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  execute() {
    return __async(this, null, function* () {
      this.close();
      this.onSubmit();
    });
  }
};
function checkRelatedFiles(app2, settings) {
  for (const srcFilePath in settings.relatedFiles) {
    for (const dstFilePath in settings.relatedFiles[srcFilePath]) {
      if (!app2.vault.getAbstractFileByPath(dstFilePath)) {
        delete settings.relatedFiles[srcFilePath][dstFilePath];
        if (Object.keys(settings.relatedFiles[srcFilePath]).length === 0) {
          delete settings.relatedFiles[srcFilePath];
        }
      }
    }
    if (!app2.vault.getAbstractFileByPath(srcFilePath)) {
      delete settings.relatedFiles[srcFilePath];
    }
  }
}
function getSubpathPosition(app2, file, subpath) {
  var _a, _b;
  if (!subpath) {
    return null;
  }
  const cache = app2.metadataCache.getFileCache(file);
  if (!cache) {
    return null;
  }
  const checkpath = (0, import_obsidian3.stripHeading)(subpath);
  if ((_a = cache.headings) == null ? void 0 : _a.length) {
    const index = cache.headings.findIndex((element) => (0, import_obsidian3.stripHeading)(element.heading) == checkpath);
    if (index >= 0) {
      return cache.headings[index].position;
    }
  }
  if ((_b = cache.sections) == null ? void 0 : _b.length) {
    const index = cache.sections.findIndex((element) => {
      element.id ? (0, import_obsidian3.stripHeading)(element.id) : checkpath == null;
    });
    if (index >= 0) {
      return cache.sections[index].position;
    }
  }
  return null;
}
function checkDataview(app2) {
  if (app2.plugins.plugins["dataview"]) {
    return true;
  } else {
    return false;
  }
}
function checkListCallouts(checkString, callouts) {
  if (!callouts)
    return null;
  for (let i = 0; i < callouts.length; i++) {
    if (checkString.startsWith(callouts[i].char + " ")) {
      return i;
    }
  }
  return null;
}
function shouldDisplayListItem(data, settings, calloutsIndex) {
  if (settings.hideCompletedTasks == true && data.task == "x") {
    return false;
  }
  if (settings.taskOnly == true && data.task === void 0) {
    return false;
  }
  if (settings.allTasks == true && data.task !== void 0) {
    return true;
  }
  if (settings.dispListCallouts == true && typeof calloutsIndex === "number") {
    return true;
  }
  if (data.level == 2 || data.level == 1 && settings.allRootItems == false) {
    return false;
  }
  return true;
}

// src/drawUI.ts
var import_obsidian5 = __toModule(require("obsidian"));

// src/FavAndRecent.ts
var import_obsidian4 = __toModule(require("obsidian"));
function updateFavAndRecent(targetPath, category, suggestType) {
  return __async(this, null, function* () {
    this.settings[suggestType][category] = this.settings[suggestType][category].filter((value) => targetPath !== value);
    this.settings[suggestType][category].unshift(targetPath);
    if (this.settings.recent[category].length > this.settings.numOfRecentFiles) {
      const numToDelete = this.settings.recent[category].length - this.settings.numOfRecentFiles;
      for (let i = 0; i < numToDelete; i++) {
        this.settings.recent[category].pop();
      }
    }
    if (this.settings.saveRecentView || this.suggestType == "favorite") {
      yield this.plugin.saveSettings();
    }
  });
}
function deleteFavAndRecent(targetPath, category, suggestType) {
  return __async(this, null, function* () {
    this.settings[suggestType][category] = this.settings[suggestType][category].filter((value) => targetPath !== value);
    if (this.settings.saveRecentView || this.suggestType == "favorite") {
      yield this.plugin.saveSettings();
    }
  });
}
var ModalJump = class extends import_obsidian4.SuggestModal {
  constructor(app2, view, category, suggestType, onSubmit) {
    super(app2);
    this.view = view;
    this.category = category;
    this.suggestType = suggestType;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    this.setPlaceholder("Jump to " + this.suggestType + " " + this.category + "s");
    this.setInstructions([
      { command: "Enter", purpose: "Jump to item" },
      { command: "Ctrl + Enter", purpose: "Add to Favorites" },
      { command: "Delete", purpose: "Remove from the list" },
      { command: "ESC", purpose: "Dismiss" }
    ]);
    this.scope.register(["Ctrl"], "Enter", (evt) => {
      var _a;
      const item = (_a = this.chooser.values) == null ? void 0 : _a[this.chooser.selectedItem];
      updateFavAndRecent.call(this.view, item, this.category, "favorite");
      this.close();
    });
    this.scope.register([], "Delete", (evt) => {
      var _a;
      const item = (_a = this.chooser.values) == null ? void 0 : _a[this.chooser.selectedItem];
      deleteFavAndRecent.call(this.view, item, this.category, this.suggestType);
      this.close();
    });
    super.onOpen();
  }
  getSuggestions(query) {
    return this.view.plugin.settings[this.suggestType][this.category].filter((target) => target.toLowerCase().includes(query.toLowerCase()));
  }
  renderSuggestion(value, el) {
    el.createEl("div", { text: value });
  }
  onChooseSuggestion(item, evt) {
    return __async(this, null, function* () {
      updateFavAndRecent.call(this.view, item, this.category, this.suggestType);
      if (this.view.settings.saveRecentView || this.suggestType == "favorite") {
        yield this.view.plugin.saveSettings();
      }
      this.onSubmit(item);
    });
  }
};
function handleRenameFavAndRecentFiles(renamedFile, oldPath, settings) {
  const renameType = renamedFile instanceof import_obsidian4.TFile ? "file" : "folder";
  let renamed = false;
  for (let i = 0; i < settings.recent[renameType].length; i++) {
    if (settings.recent[renameType][i] == oldPath) {
      settings.recent[renameType][i] = renamedFile.path;
      renamed = true;
    }
  }
  for (let i = 0; i < settings.favorite[renameType].length; i++) {
    if (settings.favorite[renameType][i] == oldPath) {
      settings.favorite[renameType][i] = renamedFile.path;
      renamed = true;
    }
  }
  return renamed;
}
function handleDeleteFavAndRecentFiles(deletedFile, settings) {
  const deleteType = deletedFile instanceof import_obsidian4.TFile ? "file" : "folder";
  let deleted = false;
  for (let i = 0; i < settings.recent[deleteType].length; i++) {
    if (settings.recent[deleteType][i] == deletedFile.path) {
      settings.recent[deleteType].splice(i, 1);
      deleted = true;
    }
  }
  for (let i = 0; i < settings.favorite[deleteType].length; i++) {
    if (settings.favorite[deleteType][i] == deletedFile.path) {
      settings.favorite[deleteType].splice(i, 1);
      deleted = true;
    }
  }
  return deleted;
}
function checkFavAndRecentFiles(app2, settings, checkType) {
  for (let i = 0; i < settings.favorite[checkType].length; i++) {
    if (!app2.vault.getAbstractFileByPath(settings.favorite[checkType][i])) {
      settings.favorite[checkType].splice(i, 1);
    }
  }
  for (let i = 0; i < settings.recent[checkType].length; i++) {
    if (!app2.vault.getAbstractFileByPath(settings.recent[checkType][i])) {
      settings.recent[checkType].splice(i, 1);
    }
  }
}

// src/drawUI.ts
function drawUI() {
  const navHeader = createDiv("nav-header");
  const navButtonContainer = navHeader.createDiv("nav-buttons-container");
  uiUpdate.call(this, navButtonContainer);
  uiFavAndRecent.call(this, navButtonContainer);
  uiSetting.call(this, navButtonContainer);
  uiToggleHeading.call(this, navButtonContainer);
  uiToggleLink.call(this, navButtonContainer);
  uiToggleListItems.call(this, navButtonContainer);
  uiToggleBacklinks.call(this, navButtonContainer);
  uiCollapse.call(this, navButtonContainer);
  this.contentEl.empty();
  this.contentEl.appendChild(navHeader);
}
function drawUIFolderView() {
  const navHeader = createDiv("nav-header");
  const navButtonContainer = navHeader.createDiv("nav-buttons-container");
  uiUpdateFolderView.call(this, navButtonContainer);
  uiFavAndRecent.call(this, navButtonContainer);
  uiSettingFolderView.call(this, navButtonContainer);
  uiToggleHeading.call(this, navButtonContainer);
  uiToggleLink.call(this, navButtonContainer);
  uiToggleListItems.call(this, navButtonContainer);
  uiToggleBacklinks.call(this, navButtonContainer);
  uiCollapse.call(this, navButtonContainer);
  this.contentEl.empty();
  this.contentEl.appendChild(navHeader);
}
function uiUpdate(parentEl) {
  const navActionButton = parentEl.createDiv("clickable-icon nav-action-button");
  if (this.pinnedMode == false) {
    navActionButton.ariaLabel = "update view";
    (0, import_obsidian5.setIcon)(navActionButton, "refresh-cw");
    navActionButton.addEventListener("click", (event) => __async(this, null, function* () {
      const file = this.app.workspace.getActiveFile();
      if (file instanceof import_obsidian5.TFile) {
        this.activeFile = file;
        this.targetFiles.main[0] = this.activeFile;
        updateFavAndRecent.call(this, this.activeFile.path, "file", "recent");
        yield this.refreshView(true, true);
      }
    }));
    navActionButton.addEventListener("contextmenu", (event) => {
      const menu = new import_obsidian5.Menu();
      menu.addItem((item) => item.setTitle("Pin").setIcon("pin").onClick(() => __async(this, null, function* () {
        this.pinnedMode = true;
        yield this.refreshView(false, false);
      })));
      menu.showAtMouseEvent(event);
    });
  } else {
    navActionButton.ariaLabel = "unpin and update view";
    (0, import_obsidian5.setIcon)(navActionButton, "pin");
    navActionButton.classList.add("is-active");
    navActionButton.addEventListener("click", (event) => __async(this, null, function* () {
      this.pinnedMode = false;
      const file = this.app.workspace.getActiveFile();
      if (file instanceof import_obsidian5.TFile) {
        this.activeFile = file;
        this.targetFiles.main[0] = this.activeFile;
        updateFavAndRecent.call(this, this.activeFile.path, "file", "recent");
        yield this.refreshView(true, true);
      }
    }));
    navActionButton.addEventListener("contextmenu", (event) => {
      const menu = new import_obsidian5.Menu();
      menu.addItem((item) => item.setTitle("Unpin").setIcon("pin-off").onClick(() => {
        this.pinnedMode = false;
        this.refreshView(false, false);
      }));
      menu.showAtMouseEvent(event);
    });
  }
}
function uiUpdateFolderView(parentEl) {
  const navActionButton = parentEl.createDiv("clickable-icon nav-action-button");
  navActionButton.ariaLabel = "update view";
  (0, import_obsidian5.setIcon)(navActionButton, "refresh-cw");
  navActionButton.addEventListener("click", (event) => __async(this, null, function* () {
    const file = this.app.workspace.getActiveFile();
    if (file instanceof import_obsidian5.TFile) {
      this.targetFolder = file.parent;
      this.hasMainChanged = true;
      updateFavAndRecent.call(this, this.targetFolder.path, "folder", "recent");
      this.refreshView(true, true);
    }
  }));
}
function uiFavAndRecent(parentEl) {
  const navActionButton = parentEl.createDiv("clickable-icon nav-action-button");
  navActionButton.ariaLabel = "favorite/recent";
  (0, import_obsidian5.setIcon)(navActionButton, "bookmark");
  navActionButton.addEventListener("click", (event) => __async(this, null, function* () {
    const onSubmit = (target) => {
      const targetObj = this.app.vault.getAbstractFileByPath(target);
      if (targetObj instanceof import_obsidian5.TFile) {
        this.targetFiles.main[0] = targetObj;
        this.hasMainChanged = true;
        if (this.settings.pinAfterJump && this.settings.autoupdateFileView) {
          this.pinnedMode = true;
        }
        updateFavAndRecent.call(this, targetObj.path, "file", "recent");
        this.refreshView(true, true);
      }
      if (targetObj instanceof import_obsidian5.TFolder) {
        this.targetFolder = targetObj;
        this.hasMainChanged = true;
        updateFavAndRecent.call(this, targetObj.path, "folder", "recent");
        this.refreshView(true, true);
      }
    };
    new ModalJump(this.app, this, this.viewType, "favorite", onSubmit).open();
  }));
  navActionButton.addEventListener("contextmenu", (event) => __async(this, null, function* () {
    event.preventDefault();
    const onSubmit = (target) => {
      const targetObj = this.app.vault.getAbstractFileByPath(target);
      if (targetObj instanceof import_obsidian5.TFile) {
        this.targetFiles.main[0] = targetObj;
        this.hasMainChanged = true;
        if (this.settings.pinAfterJump && this.settings.autoupdateFileView) {
          this.pinnedMode = true;
        }
        updateFavAndRecent.call(this, targetObj.path, "file", "recent");
        this.refreshView(true, true);
      }
      if (targetObj instanceof import_obsidian5.TFolder) {
        this.targetFolder = targetObj;
        this.hasMainChanged = true;
        updateFavAndRecent.call(this, targetObj.path, "folder", "recent");
        this.refreshView(true, true);
      }
    };
    new ModalJump(this.app, this, this.viewType, "recent", onSubmit).open();
  }));
}
function uiSetting(parentEl) {
  const navActionButton = parentEl.createDiv("clickable-icon nav-action-button");
  navActionButton.ariaLabel = "open settings";
  (0, import_obsidian5.setIcon)(navActionButton, "settings");
  navActionButton.addEventListener("click", (event) => __async(this, null, function* () {
    this.app.setting.open();
    this.app.setting.openTabById(this.plugin.manifest.id);
  }));
  navActionButton.addEventListener("contextmenu", (event) => {
    const menu = new import_obsidian5.Menu();
    for (const category in this.settings.showFiles) {
      const icon2 = this.settings.showFiles[category] == true ? "check" : "";
      menu.addItem((item) => item.setTitle(`show ${category} section`).setIcon(icon2).onClick(() => __async(this, null, function* () {
        this.settings.showFiles[category] = !this.settings.showFiles[category];
        yield this.plugin.saveSettings();
        this.refreshView(false, false);
      })));
    }
    menu.addSeparator();
    for (const element in this.settings.showElements) {
      const icon2 = this.settings.showElements[element] == true ? "check" : "";
      menu.addItem((item) => item.setTitle(`show ${element}`).setIcon(icon2).onClick(() => __async(this, null, function* () {
        this.settings.showElements[element] = !this.settings.showElements[element];
        yield this.plugin.saveSettings();
        this.refreshView(false, false);
      })));
    }
    if (this.settings.showElements.listItems) {
      const icon2 = this.settings.taskOnly ? "check" : "";
      menu.addItem((item) => item.setTitle("tasks only").setIcon(icon2).onClick(() => __async(this, null, function* () {
        this.settings.taskOnly = !this.settings.taskOnly;
        yield this.plugin.saveSettings();
        this.refreshView(false, false);
      })));
    }
    let icon = this.settings.showBacklinks ? "check" : "";
    menu.addItem((item) => item.setTitle("show 2-hop backlinks").setIcon(icon).onClick(() => __async(this, null, function* () {
      this.settings.showBacklinks = !this.settings.showBacklinks;
      yield this.plugin.saveSettings();
      this.refreshView(false, false);
    })));
    menu.addSeparator();
    icon = this.settings.tooltipPreview ? "check" : "";
    menu.addItem((item) => item.setTitle("show tooltip preview").setIcon(icon).onClick(() => __async(this, null, function* () {
      this.settings.tooltipPreview = !this.settings.tooltipPreview;
      yield this.plugin.saveSettings();
      this.refreshView(false, false);
    })));
    menu.showAtMouseEvent(event);
  });
}
function uiSettingFolderView(parentEl, instance) {
  const navActionButton = parentEl.createDiv("clickable-icon nav-action-button");
  navActionButton.ariaLabel = "open settings";
  (0, import_obsidian5.setIcon)(navActionButton, "settings");
  navActionButton.addEventListener("click", (event) => __async(this, null, function* () {
    this.app.setting.open();
    this.app.setting.openTabById(this.plugin.manifest.id);
  }));
  navActionButton.addEventListener("contextmenu", (event) => {
    const menu = new import_obsidian5.Menu();
    for (const element in this.settings.showElements) {
      const icon2 = this.settings.showElements[element] == true ? "check" : "";
      menu.addItem((item) => item.setTitle(`show ${element}`).setIcon(icon2).onClick(() => __async(this, null, function* () {
        this.settings.showElements[element] = !this.settings.showElements[element];
        yield this.plugin.saveSettings();
        this.refreshView(false, false);
      })));
    }
    if (this.settings.showElements.listItems) {
      const icon2 = this.settings.taskOnly ? "check" : "";
      menu.addItem((item) => item.setTitle("tasks only").setIcon(icon2).onClick(() => __async(this, null, function* () {
        this.settings.taskOnly = !this.settings.taskOnly;
        yield this.plugin.saveSettings();
        this.refreshView(false, false);
      })));
    }
    let icon = this.settings.showBacklinks ? "check" : "";
    menu.addItem((item) => item.setTitle("show 2-hop backlinks").setIcon(icon).onClick(() => __async(this, null, function* () {
      this.settings.showBacklinks = !this.settings.showBacklinks;
      yield this.plugin.saveSettings();
      this.refreshView(false, false);
    })));
    menu.addSeparator();
    icon = this.settings.tooltipPreview ? "check" : "";
    menu.addItem((item) => item.setTitle("show tooltip preview").setIcon(icon).onClick(() => __async(this, null, function* () {
      this.settings.tooltipPreview = !this.settings.tooltipPreview;
      yield this.plugin.saveSettings();
      this.refreshView(false, false);
    })));
    menu.addSeparator();
    icon = this.settings.collapseFolder ? "check" : "";
    menu.addItem((item) => item.setTitle("collapse subfolder").setIcon(icon).onClick(() => __async(this, null, function* () {
      this.settings.collapseFolder = !this.settings.collapseFolder;
      yield this.plugin.saveSettings();
      this.refreshView(true, true);
    })));
    menu.showAtMouseEvent(event);
  });
}
function uiToggleHeading(parentEl) {
  const navActionButton = parentEl.createDiv("clickable-icon nav-action-button");
  navActionButton.ariaLabel = "toggle headings";
  (0, import_obsidian5.setIcon)(navActionButton, "heading");
  if (this.settings.showElements.heading) {
    navActionButton.classList.add("is-active");
  }
  navActionButton.addEventListener("click", (event) => __async(this, null, function* () {
    this.settings.showElements.heading = !this.settings.showElements.heading;
    this.refreshView(false, false);
  }));
  navActionButton.addEventListener("contextmenu", (event) => {
    const menu = new import_obsidian5.Menu();
    menu.addItem((item) => item.setTitle("heading level to display"));
    for (let i = 0; i < 6; i++) {
      const dispText = i == 0 ? "H1" : "H1 - H" + (i + 1).toString();
      menu.addItem((item) => item.setTitle(dispText).onClick(() => __async(this, null, function* () {
        this.settings.maxHeadingLevel = i + 1;
        yield this.plugin.saveSettings();
        this.refreshView(false, false);
      })));
    }
    menu.showAtMouseEvent(event);
  });
}
function uiToggleLink(parentEl) {
  const navActionButton = parentEl.createDiv("clickable-icon nav-action-button");
  navActionButton.ariaLabel = "toggle links";
  (0, import_obsidian5.setIcon)(navActionButton, "link");
  if (this.settings.showElements.link) {
    navActionButton.classList.add("is-active");
  }
  navActionButton.addEventListener("click", (event) => __async(this, null, function* () {
    this.settings.showElements.link = !this.settings.showElements.link;
    this.refreshView(false, false);
  }));
}
function uiToggleListItems(parentEl) {
  const navActionButton = parentEl.createDiv("clickable-icon nav-action-button");
  navActionButton.ariaLabel = "toggle list items";
  (0, import_obsidian5.setIcon)(navActionButton, "list");
  if (this.settings.showElements.listItems) {
    navActionButton.classList.add("is-active");
  }
  navActionButton.addEventListener("click", (event) => __async(this, null, function* () {
    this.settings.showElements.listItems = !this.settings.showElements.listItems;
    this.refreshView(false, false);
  }));
}
function uiToggleBacklinks(parentEl) {
  const navActionButton = parentEl.createDiv("clickable-icon nav-action-button");
  navActionButton.ariaLabel = "toggle backlinks";
  (0, import_obsidian5.setIcon)(navActionButton, "links-coming-in");
  if (this.settings.showBacklinks) {
    navActionButton.classList.add("is-active");
  }
  navActionButton.addEventListener("click", (event) => __async(this, null, function* () {
    this.settings.showBacklinks = !this.settings.showBacklinks;
    this.refreshView(false, false);
  }));
}
function uiCollapse(parentEl) {
  const navActionButton = parentEl.createDiv("clickable-icon nav-action-button");
  if (this.collapseAll) {
    navActionButton.classList.add("is-active");
  }
  if (!this.collapseAll) {
    navActionButton.ariaLabel = "collapse all";
    (0, import_obsidian5.setIcon)(navActionButton, "chevrons-down-up");
    navActionButton.addEventListener("click", (event) => __async(this, null, function* () {
      this.collapseAll = true;
      this.refreshView(false, false);
    }));
  } else {
    navActionButton.ariaLabel = "expand";
    (0, import_obsidian5.setIcon)(navActionButton, "chevrons-down-up");
    navActionButton.addEventListener("click", (event) => __async(this, null, function* () {
      this.collapseAll = false;
      this.refreshView(false, false);
    }));
  }
}

// src/constructOutlineDOM.ts
var import_obsidian6 = __toModule(require("obsidian"));
var import_electron = __toModule(require("electron"));
function constructOutlineDOM(file, info, data, parentEl, category) {
  var _a, _b, _c, _d, _e, _f;
  const isCanvas = Boolean(file.extension == "canvas");
  if (this.settings.showPropertyLinks && info.frontmatterLinks && !(category == "outgoing" && this.settings.hideMinor2hopLink)) {
    for (let j = 0; j < info.frontmatterLinks.length; j++) {
      const linkTarget = this.app.metadataCache.getFirstLinkpathDest((0, import_obsidian6.parseLinktext)(info.frontmatterLinks[j].link).path, file.path);
      if (!(linkTarget instanceof import_obsidian6.TFile)) {
        continue;
      }
      const linkSubpath = (0, import_obsidian6.parseLinktext)(info.frontmatterLinks[j].link).subpath;
      const subPathPosition = getSubpathPosition(this.app, linkTarget, linkSubpath);
      if (!checkLinksBetweenRelatedFiles(linkTarget, category, this.settings, this.targetFiles)) {
        continue;
      }
      const outlineEl = parentEl.createDiv("tree-item nav-file");
      const outlineTitle = outlineEl.createDiv("tree-item-self is-clickable nav-file-title");
      (0, import_obsidian6.setIcon)(outlineTitle, "link");
      outlineTitle.style.paddingLeft = "0.5em";
      outlineTitle.createDiv("tree-item-inner nav-file-title-content").setText(info.frontmatterLinks[j].displayText);
      outlineTitle.addEventListener("click", (event) => __async(this, null, function* () {
        if (this.settings.openLinkByClick) {
          yield openElementPosition(linkTarget, subPathPosition, void 0, this.app);
          this.holdUpdateOnce = Boolean(linkTarget != this.activeFile);
        } else {
          yield openElementPosition(file, null, void 0, this.app);
          this.holdUpdateOnce = Boolean(file != this.activeFile);
        }
      }), false);
      outlineTitle.addEventListener("mouseover", (event) => {
        var _a2;
        if (linkTarget) {
          this.app.workspace.trigger("hover-link", {
            event,
            source: MultipleNotesOutlineViewType,
            hoverParent: parentEl,
            targetEl: outlineTitle,
            linktext: linkTarget.path,
            state: { scroll: (_a2 = subPathPosition == null ? void 0 : subPathPosition.start) == null ? void 0 : _a2.line }
          });
        }
      });
      outlineTitle.addEventListener("contextmenu", (event) => {
        const menu = new import_obsidian6.Menu();
        menu.addItem((item) => item.setTitle("Open linked file").setIcon("links-going-out").onClick(() => __async(this, null, function* () {
          yield openElementPosition(linkTarget, subPathPosition, void 0, this.app);
          this.holdUpdateOnce = Boolean(linkTarget != this.activeFile);
        })));
        menu.addSeparator();
        menu.addItem((item) => item.setTitle("Open linked file in new tab").setIcon("file-plus").onClick(() => __async(this, null, function* () {
          yield openElementPosition(linkTarget, subPathPosition, "tab", this.app);
          this.holdUpdateOnce = Boolean(linkTarget != this.activeFile);
        })));
        menu.addItem((item) => item.setTitle("Open linked file to the right").setIcon("separator-vertical").onClick(() => __async(this, null, function* () {
          yield openElementPosition(linkTarget, subPathPosition, "split", this.app);
          this.holdUpdateOnce = Boolean(linkTarget != this.activeFile);
        })));
        menu.addItem((item) => item.setTitle("Open linked file in new window").setIcon("scan").onClick(() => __async(this, null, function* () {
          yield openElementPositionInPopoutWindow(linkTarget, subPathPosition, this.settings, this.app);
          this.holdUpdateOnce = Boolean(linkTarget != this.activeFile);
        })));
        menu.addSeparator();
        menu.addItem((item) => item.setTitle("Open in new tab").setIcon("file-plus").onClick(() => __async(this, null, function* () {
          yield openElementPosition(file, null, "tab", this.app);
          this.holdUpdateOnce = Boolean(file != this.activeFile);
        })));
        menu.addItem((item) => item.setTitle("Open to the right").setIcon("separator-vertical").onClick(() => __async(this, null, function* () {
          yield openElementPosition(file, null, "split", this.app);
          this.holdUpdateOnce = Boolean(file != this.activeFile);
        })));
        menu.addItem((item) => item.setTitle("Open in new window").setIcon("scan").onClick(() => __async(this, null, function* () {
          yield openElementPositionInPopoutWindow(file, null, this.settings, this.app);
          this.holdUpdateOnce = Boolean(file != this.activeFile);
        })));
        menu.showAtMouseEvent(event);
      });
    }
  }
  let latestHeadingLevel = 0;
  if (data.length > 0) {
    for (let j = 0; j < data.length; j++) {
      const element = data[j].typeOfElement;
      let displayText = data[j].displayText;
      const linkTarget = element !== "link" ? null : this.app.metadataCache.getFirstLinkpathDest((0, import_obsidian6.parseLinktext)((_a = data[j]) == null ? void 0 : _a.link).path, file.path);
      const linkSubpath = !linkTarget ? null : (0, import_obsidian6.parseLinktext)((_b = data[j]) == null ? void 0 : _b.link).subpath;
      const subPathPosition = getSubpathPosition(this.app, linkTarget, linkSubpath);
      if (this.settings.showElements[element] == false) {
        continue;
      }
      if (element == "heading") {
        latestHeadingLevel = data[j].level;
        if (data[j].level > this.settings.maxHeadingLevel) {
          continue;
        }
      }
      if (element == "link") {
        if (checkLinksBetweenRelatedFiles(linkTarget, category, this.settings, this.targetFiles) == false) {
          continue;
        }
        if (this.settings.hideMinor2hopLink && category == "outgoing") {
          continue;
        }
      }
      let calloutsIndex = void 0;
      if (element == "listItems") {
        if (this.settings.dispListCallouts) {
          calloutsIndex = checkListCallouts(displayText, (_d = (_c = this.app.plugins.plugins) == null ? void 0 : _c["obsidian-list-callouts"]) == null ? void 0 : _d.settings);
        }
        if (shouldDisplayListItem(data[j], this.settings, calloutsIndex) == false) {
          continue;
        }
      }
      const outlineEl = parentEl.createDiv("tree-item nav-file");
      const outlineTitle = outlineEl.createDiv("tree-item-self is-clickable nav-file-title");
      switch (this.settings.icon[element]) {
        case "none":
          break;
        case "headingwithnumber":
          (0, import_obsidian6.setIcon)(outlineTitle, `heading-${data[j].level}`);
          break;
        case "custom":
          (0, import_obsidian6.setIcon)(outlineTitle, this.settings.customIcon[element]);
          break;
        default:
          (0, import_obsidian6.setIcon)(outlineTitle, this.settings.icon[element]);
          break;
      }
      if (element == "listItems" && data[j].task !== void 0) {
        if (data[j].task == "x") {
          (0, import_obsidian6.setIcon)(outlineTitle, this.settings.icon.taskDone == "custom" ? this.settings.customIcon.taskDone : this.settings.icon.taskDone);
        } else {
          (0, import_obsidian6.setIcon)(outlineTitle, this.settings.icon.task == "custom" ? this.settings.customIcon.task : this.settings.icon.task);
        }
      }
      if (element == "listItems") {
        if (data[j].task !== void 0) {
          if (data[j].task == "x") {
            (0, import_obsidian6.setIcon)(outlineTitle, this.settings.icon.taskDone == "custom" ? this.settings.customIcon.taskDone : this.settings.icon.taskDone);
          } else {
            (0, import_obsidian6.setIcon)(outlineTitle, this.settings.icon.task == "custom" ? this.settings.customIcon.task : this.settings.icon.task);
          }
        }
        if (typeof calloutsIndex == "number") {
          outlineTitle.style.backgroundColor = `RGBA(${this.app.plugins.plugins["obsidian-list-callouts"].settings[calloutsIndex].color},0.15)`;
          if (this.app.plugins.plugins["obsidian-list-callouts"].settings[calloutsIndex].hasOwnProperty("icon") && data[j].task === void 0) {
            (0, import_obsidian6.setIcon)(outlineTitle, this.app.plugins.plugins["obsidian-list-callouts"].settings[calloutsIndex].icon);
            displayText = displayText.replace(/^.\s/, "");
          }
        }
      }
      let prefix = this.settings.prefix[element];
      if (element == "heading") {
        switch (this.settings.repeatHeadingPrefix) {
          case "level":
            prefix = prefix.repeat(data[j].level);
            break;
          case "levelminus1":
            prefix = prefix.repeat(data[j].level - 1);
            break;
        }
      }
      let indent = 0.5;
      if (element == "heading" && this.settings.indent.heading == true) {
        indent = indent + (data[j].level - 1) * 1.5;
      }
      if (element != "heading" && this.settings.indentFollowHeading) {
        const additionalIndent = (latestHeadingLevel - 1 + (this.settings.indentFollowHeading == 2 ? 1 : 0)) * 1.5;
        indent = indent + (additionalIndent > 0 ? additionalIndent : 0);
      }
      if (!isCanvas && element == "link" && data[j].position.start.line == ((_e = data[j - 1]) == null ? void 0 : _e.position.start.line)) {
        indent = indent + 1.5;
      }
      outlineTitle.style.paddingLeft = `${indent}em`;
      if (element == "listItems" && data[j].task !== void 0) {
        prefix = data[j].task == "x" ? this.settings.prefix.taskDone : this.settings.prefix.task;
        if (this.settings.addCheckboxText) {
          prefix = prefix + "[" + data[j].task + "] ";
        }
      }
      const outlineTitleContent = outlineTitle.createDiv("tree-item-inner nav-file-title-content");
      outlineTitleContent.setText(prefix + displayText);
      if (this.settings.wrapLine) {
        outlineTitleContent.classList.add("wrap-line");
      }
      if (!isCanvas && this.settings.inlinePreview) {
        let previewText = "";
        if ((element == "link" || element == "tag") && data[j].position.end.col < info.lines[data[j].position.start.line].length) {
          previewText = info.lines[data[j].position.start.line].slice(data[j].position.end.col);
        } else {
          previewText = data[j].position.start.line < info.numOfLines - 1 ? info.lines[data[j].position.start.line + 1] : "";
        }
        outlineTitle.createDiv("nav-file-title-preview").setText(previewText);
      }
      if (this.settings.tooltipPreview) {
        if (!isCanvas) {
          const previewText2 = makeTooltipPreviewText(j, info, data, this.settings);
          (0, import_obsidian6.setTooltip)(outlineTitle, previewText2, { classes: ["MNO-preview"] });
          outlineTitle.dataset.tooltipPosition = this.settings.tooltipPreviewDirection;
          outlineTitle.setAttribute("data-tooltip-delay", "10");
        } else {
          if (data[j].typeOfElement == "listItems") {
            (0, import_obsidian6.setTooltip)(outlineTitle, data[j].displayText, { classes: ["MNO-preview"] });
            outlineTitle.dataset.tooltipPosition = this.settings.tooltipPreviewDirection;
            outlineTitle.setAttribute("data-tooltip-delay", "10");
          }
        }
      }
      if (element == "link") {
        outlineTitle.setAttr("draggable", "true");
        outlineTitle.addEventListener("dragstart", (event) => {
          const linkText = data[j].link;
          const dragManager = this.app.dragManager;
          const dragData = dragManager.dragLink(event, linkText, "\u30BF\u30A4\u30C8\u30EB", linkText);
          dragManager.onDragStart(event, dragData);
        });
      } else if (element == "heading") {
        outlineTitle.setAttr("draggable", "true");
        outlineTitle.addEventListener("dragstart", (event) => {
          const linkText = file.path + "#" + (0, import_obsidian6.stripHeadingForLink)(data[j].displayText);
          const dragManager = this.app.dragManager;
          const dragData = dragManager.dragLink(event, linkText, "\u30BF\u30A4\u30C8\u30EB", linkText);
          dragManager.onDragStart(event, dragData);
        });
      }
      outlineTitle.addEventListener("click", (event) => __async(this, null, function* () {
        if (this.settings.openLinkByClick == true && element == "link") {
          yield openElementPosition(linkTarget, subPathPosition, void 0, this.app);
          this.holdUpdateOnce = Boolean(linkTarget != this.activeFile);
        } else if (!isCanvas) {
          yield openElementPosition(file, data[j].position, void 0, this.app);
          this.holdUpdateOnce = Boolean(file != this.activeFile);
        }
      }), false);
      outlineTitle.addEventListener("mouseover", (event) => {
        var _a2;
        if (element == "link" && linkTarget) {
          this.app.workspace.trigger("hover-link", {
            event,
            source: MultipleNotesOutlineViewType,
            hoverParent: parentEl,
            targetEl: outlineTitle,
            linktext: linkTarget.path,
            state: { scroll: (_a2 = subPathPosition == null ? void 0 : subPathPosition.start) == null ? void 0 : _a2.line }
          });
        } else {
          if (!isCanvas) {
            this.app.workspace.trigger("hover-link", {
              event,
              source: MultipleNotesOutlineViewType,
              hoverParent: parentEl,
              targetEl: outlineTitle,
              linktext: file.path,
              state: { scroll: data[j].position.start.line }
            });
          }
        }
      });
      outlineTitle.addEventListener("contextmenu", (event) => {
        const menu = new import_obsidian6.Menu();
        if (element == "link") {
          menu.addItem((item) => item.setTitle("Open linked file").setIcon("links-going-out").onClick(() => __async(this, null, function* () {
            yield openElementPosition(linkTarget, subPathPosition, void 0, this.app);
            this.holdUpdateOnce = Boolean(linkTarget != this.activeFile);
          })));
          menu.addSeparator();
          menu.addItem((item) => item.setTitle("Open linked file in new tab").setIcon("file-plus").onClick(() => __async(this, null, function* () {
            yield openElementPosition(linkTarget, subPathPosition, "tab", this.app);
            this.holdUpdateOnce = Boolean(linkTarget != this.activeFile);
          })));
          menu.addItem((item) => item.setTitle("Open linked file to the right").setIcon("separator-vertical").onClick(() => __async(this, null, function* () {
            yield openElementPosition(linkTarget, subPathPosition, "split", this.app);
            this.holdUpdateOnce = Boolean(linkTarget != this.activeFile);
          })));
          menu.addItem((item) => item.setTitle("Open linked file in new window").setIcon("scan").onClick(() => __async(this, null, function* () {
            yield openElementPositionInPopoutWindow(linkTarget, subPathPosition, this.settings, this.app);
            this.holdUpdateOnce = Boolean(linkTarget != this.activeFile);
          })));
          menu.addSeparator();
        }
        if (element == "tag") {
          menu.addItem((item) => item.setTitle("Search this tag").setIcon("search").onClick(() => __async(this, null, function* () {
            var _a2;
            const searchString = "tag: #" + displayText;
            (_a2 = this.app.internalPlugins.plugins["global-search"]) == null ? void 0 : _a2.instance.openGlobalSearch(searchString);
          })));
          menu.addSeparator();
        }
        if (!isCanvas) {
          menu.addItem((item) => item.setTitle("Open in new tab").setIcon("file-plus").onClick(() => __async(this, null, function* () {
            yield openElementPosition(file, data[j].position, "tab", this.app);
            this.holdUpdateOnce = Boolean(file != this.activeFile);
          })));
          menu.addItem((item) => item.setTitle("Open to the right").setIcon("separator-vertical").onClick(() => __async(this, null, function* () {
            yield openElementPosition(file, data[j].position, "split", this.app);
            this.holdUpdateOnce = Boolean(file != this.activeFile);
          })));
          menu.addItem((item) => item.setTitle("Open in new window").setIcon("scan").onClick(() => __async(this, null, function* () {
            yield openElementPositionInPopoutWindow(file, data[j].position, this.settings, this.app);
            this.holdUpdateOnce = Boolean(file != this.activeFile);
          })));
          if (element == "heading" || element == "link") {
            menu.addSeparator();
            menu.addItem((item) => item.setTitle("Copy link").setIcon("copy").onClick(() => __async(this, null, function* () {
              if (this.app.vault.config.useMarkdownLinks) {
                const linkText = element == "link" ? this.app.fileManager.generateMarkdownLink(linkTarget, "", linkSubpath, linkTarget.basename + linkSubpath) : this.app.fileManager.generateMarkdownLink(file, "", "#" + (0, import_obsidian6.stripHeadingForLink)(data[j].displayText), file.basename + "#" + (0, import_obsidian6.stripHeadingForLink)(data[j].displayText));
                yield navigator.clipboard.writeText(linkText);
              } else {
                const linkText = element == "link" ? `[[${data[j].link}]]` : `[[${file.basename}#${(0, import_obsidian6.stripHeadingForLink)(data[j].displayText)}]]`;
                yield navigator.clipboard.writeText(linkText);
              }
            })));
          }
        }
        menu.showAtMouseEvent(event);
      });
    }
  } else {
    if (true) {
      for (let j = 0; j < info.lines.length; j++) {
        if (info.lines[j] == "") {
          continue;
        } else {
          const outlineEl = parentEl.createDiv("tree-item nav-file");
          const outlineTitle = outlineEl.createDiv("tree-item-self is-clickable nav-file-title");
          outlineTitle.createDiv("tree-item-inner nav-file-title-content").setText(info.lines[j]);
          outlineTitle.addEventListener("click", (event) => __async(this, null, function* () {
            if (file != this.activeFile) {
              this.holdUpdateOnce = true;
            }
            event.preventDefault();
            yield this.app.workspace.getLeaf().openFile(file);
          }), false);
          const previewText2 = info.lines.join("\n");
          (0, import_obsidian6.setTooltip)(outlineTitle, previewText2, { classes: ["MNO-preview"] });
          outlineTitle.dataset.tooltipPosition = this.settings.tooltipPreviewDirection;
          outlineTitle.setAttribute("data-tooltip-delay", "10");
          break;
        }
      }
    }
  }
  if (category == "main" || this.settings.showBacklinks == false || !info.backlinks || category == "backlink" && this.settings.hideMinor2hopLink) {
    return;
  }
  backlinkfileloop:
    for (let i = 0; i < ((_f = info.backlinks) == null ? void 0 : _f.length); i++) {
      for (const targetCategory in this.targetFiles) {
        if (this.targetFiles[targetCategory].includes(info.backlinks[i])) {
          continue backlinkfileloop;
        }
      }
      const outlineEl = parentEl.createDiv("tree-item nav-file");
      const outlineTitle = outlineEl.createDiv("tree-item-self is-clickable nav-file-title");
      switch (this.settings.icon.backlink) {
        case "none":
          break;
        case "custom":
          (0, import_obsidian6.setIcon)(outlineTitle, this.settings.customIcon.backlink);
          break;
        default:
          (0, import_obsidian6.setIcon)(outlineTitle, this.settings.icon.backlink);
          break;
      }
      outlineTitle.style.paddingLeft = "0.5em";
      outlineTitle.createDiv("tree-item-inner nav-file-title-content").setText(info.backlinks[i].basename);
      outlineTitle.addEventListener("click", (event) => __async(this, null, function* () {
        yield openElementPosition(info.backlinks[i], null, void 0, this.app);
        this.holdUpdateOnce = Boolean(info.backlinks[i] != this.activeFile);
      }), false);
      outlineTitle.addEventListener("mouseover", (event) => {
        this.app.workspace.trigger("hover-link", {
          event,
          source: MultipleNotesOutlineViewType,
          hoverParent: parentEl,
          targetEl: outlineTitle,
          linktext: info.backlinks[i].path
        });
      });
      outlineTitle.addEventListener("contextmenu", (event) => {
        const menu = new import_obsidian6.Menu();
        menu.addItem((item) => item.setTitle("Open backlink file in new tab").setIcon("file-plus").onClick(() => __async(this, null, function* () {
          yield openElementPosition(info.backlinks[i], null, "tab", this.app);
          this.holdUpdateOnce = Boolean(info.backlinks[i] != this.activeFile);
        })));
        menu.addItem((item) => item.setTitle("Open backlink file to the right").setIcon("separator-vertical").onClick(() => __async(this, null, function* () {
          yield openElementPosition(info.backlinks[i], null, "split", this.app);
          this.holdUpdateOnce = Boolean(info.backlinks[i] != this.activeFile);
        })));
        menu.addItem((item) => item.setTitle("Open backlink file in new window").setIcon("scan").onClick(() => __async(this, null, function* () {
          yield openElementPositionInPopoutWindow(info.backlinks[i], null, this.settings, this.app);
          this.holdUpdateOnce = Boolean(info.backlinks[i] != this.activeFile);
        })));
        menu.showAtMouseEvent(event);
      });
    }
}
function openElementPosition(file, position, method, app2) {
  return __async(this, null, function* () {
    var _a;
    yield app2.workspace.getLeaf(method).openFile(file);
    if (position) {
      scrollToElement((_a = position.start) == null ? void 0 : _a.line, 0, app2);
    }
  });
}
function openElementPositionInPopoutWindow(file, position, settings, app2) {
  return __async(this, null, function* () {
    var _a;
    yield this.app.workspace.openPopoutLeaf({
      size: {
        width: settings.popoutSize.width,
        height: settings.popoutSize.height
      }
    }).openFile(file);
    if (position) {
      scrollToElement((_a = position.start) == null ? void 0 : _a.line, 0, this.app);
    }
    if (settings.popoutAlwaysOnTop) {
      setPopoutAlwaysOnTop2();
    }
  });
}
function scrollToElement(line, col, app2) {
  const view = app2.workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
  if (view) {
    view.setEphemeralState({ line });
  }
}
function setPopoutAlwaysOnTop2() {
  const activeWindow = import_electron.remote.BrowserWindow.getFocusedWindow();
  activeWindow.setAlwaysOnTop(true);
}
function checkLinksBetweenRelatedFiles(linkTarget, category, settings, targetFiles) {
  var _a, _b;
  if (!linkTarget) {
    return true;
  }
  if (settings.hideLinksBetweenRelatedFiles == "mainOnly") {
    if (category == "main") {
      return false;
    }
    if (linkTarget.path == ((_a = targetFiles.main) == null ? void 0 : _a[0].path)) {
      return false;
    }
  }
  if (settings.hideLinksBetweenRelatedFiles == "toMainOnly") {
    if (linkTarget.path == ((_b = targetFiles.main) == null ? void 0 : _b[0].path)) {
      return false;
    }
  }
  if (settings.hideLinksBetweenRelatedFiles == "all") {
    for (const category2 in targetFiles) {
      if (targetFiles[category2].some((targetfile) => targetfile.path == linkTarget.path)) {
        return false;
      }
    }
  }
  return true;
}
function makeTooltipPreviewText(j, info, data, settings) {
  let previewText = "";
  let endLine = info.numOfLines - 1;
  let k = j + 1;
  while (k < data.length) {
    if (settings.showElements[data[k].typeOfElement]) {
      if (data[k].typeOfElement == "listItems" && (data[k].level >= 2 || settings.allRootItems == false && data[k].level == 1 && (settings.allTasks == false || data[k].task === void 0) || settings.taskOnly && data[k].task === void 0 || settings.hideCompletedTasks && data[k].task == "x")) {
        k++;
        continue;
      } else if (data[k].typeOfElement == "heading" && data[k].level > settings.maxHeadingLevel) {
        k++;
        continue;
      } else {
        endLine = data[k].position.start.line - 1;
        break;
      }
    }
    k++;
  }
  for (let l = data[j].position.start.line; l <= endLine; l++) {
    previewText = previewText + info.lines[l] + "\n";
  }
  previewText = previewText.replace(/\n$|\n(?=\n)/g, "");
  return previewText;
}

// src/constructNoteDOM.ts
var import_obsidian7 = __toModule(require("obsidian"));
function constructNoteDOM(files, status, info, data, parentEl, category, aotEl, srcFile, order) {
  var _a, _b, _c;
  for (let i = 0; i < files.length; i++) {
    const si = order[i];
    if (Object.values(status[si].duplicated).includes(true) && this.settings.hideDuplicated) {
      continue;
    }
    const noteType = status[si].isFolder ? "folder" : "file";
    const belongsAOT = Boolean(status[si].isTop == true && !Object.values(status[si].duplicated).includes(true)) && category != "main";
    let noteEl;
    if (belongsAOT) {
      noteEl = aotEl.createDiv("tree-item nav-folder");
    } else {
      noteEl = parentEl.createDiv("tree-item nav-folder");
    }
    const noteTitleEl = noteEl.createDiv("tree-item-self is-clickable mod-collapsible nav-folder-title");
    let nIcon;
    if (belongsAOT) {
      nIcon = "pin";
    } else {
      if (noteType == "folder") {
        nIcon = "folder";
      } else {
        nIcon = "file";
      }
    }
    (0, import_obsidian7.setIcon)(noteTitleEl, nIcon);
    if (!noteEl.parentElement.classList.contains("mod-root")) {
      noteTitleEl.classList.add("is-subfolder");
    }
    const noteChildrenEl = noteEl.createDiv("tree-item-children nav-folder-children");
    noteChildrenEl.id = "MNO" + this.viewType + files[si].path;
    const noteCollapseIcon = noteTitleEl.createDiv("tree-item-icon collapse-icon nav-folder-collapse-indicator");
    (0, import_obsidian7.setIcon)(noteCollapseIcon, "right-triangle");
    noteCollapseIcon.addEventListener("click", (event) => __async(this, null, function* () {
      var _a2;
      event.stopPropagation();
      if (!status[si].outlineReady) {
        if (noteType == "folder") {
          yield this.processFolder(files[si]);
          status[si].outlineReady = true;
          noteEl.classList.remove("is-collapsed");
          noteCollapseIcon.classList.remove("is-collapsed");
          constructNoteDOM.call(this, this.targetFiles[files[si].path], this.fileStatus[files[si].path], this.fileInfo[files[si].path], this.outlineData[files[si].path], noteChildrenEl, "folder", aotEl, srcFile, this.fileOrder[files[si].path]);
          noteEl.appendChild(noteChildrenEl);
        } else if (((_a2 = files[si]) == null ? void 0 : _a2.extension) == "md") {
          info[si] = yield getFileInfo(this.app, files[si], this.settings, false, this.isDataviewEnabled);
          data[si] = yield getOutline(this.app, files[si], status[si], info[si], this.settings);
          status[si].outlineReady = true;
          noteEl.classList.remove("is-collapsed");
          noteCollapseIcon.classList.remove("is-collapsed");
          attachFileInfo(noteTitleEl, status[si], info[si], data[si], this.settings.displayFileInfo);
          constructOutlineDOM.call(this, files[si], info[si], data[si], noteChildrenEl, category);
        } else {
        }
      } else if (status[si].isFolded) {
        if (!this.collapseAll && (!status[si].duplicated.main || !this.settings.showFiles.main) && (!status[si].duplicated.outgoing || !this.settings.showFiles.outgoing) && !status[si].duplicated.self) {
          if (checkFlag(srcFile, files[si], "fold", this.settings)) {
            removeFlag(srcFile, files[si], "fold", this.settings);
            yield this.plugin.saveSettings();
          }
        }
        noteEl.classList.remove("is-collapsed");
        noteCollapseIcon.classList.remove("is-collapsed");
        status[si].isFolded = false;
        noteChildrenEl.style.display = "block";
      } else {
        if (!this.collapseAll && (!status[si].duplicated.main || !this.settings.showFiles.main) && (!status[si].duplicated.outgoing || !this.settings.showFiles.outgoing) && !status[si].duplicated.self) {
          addFlag(srcFile, files[si], "fold", this.settings);
        }
        yield this.plugin.saveSettings();
        noteEl.classList.add("is-collapsed");
        noteCollapseIcon.classList.add("is-collapsed");
        status[si].isFolded = true;
        noteChildrenEl.style.display = "none";
      }
    }));
    let nameLabel = noteType == "folder" ? files[si].name : files[si].basename;
    if (noteType == "folder") {
      nameLabel = files[si].name;
    } else {
      nameLabel = files[si].basename;
      if (files[si].extension !== "md") {
        nameLabel = nameLabel + "." + files[si].extension;
      }
    }
    noteTitleEl.createDiv("tree-item-inner nav-folder-title-content").setText(nameLabel);
    attachFileInfo(noteTitleEl, status[si], info[si], data[si], this.settings.displayFileInfo);
    if (files[si] instanceof import_obsidian7.TFile) {
      noteTitleEl.setAttr("draggable", "true");
      noteTitleEl.addEventListener("dragstart", (event) => {
        const dragManager = this.app.dragManager;
        const dragData = dragManager.dragFile(event, files[si]);
        dragManager.onDragStart(event, dragData);
      });
    }
    if (noteType == "file") {
      noteTitleEl.addEventListener("click", (event) => {
        if (files[si] != this.activeFile) {
          this.holdUpdateOnce = true;
        }
        this.app.workspace.getLeaf().openFile(files[si]);
      }, false);
      noteTitleEl.addEventListener("mouseover", (event) => {
        this.app.workspace.trigger("hover-link", {
          event,
          source: MultipleNotesOutlineViewType,
          hoverParent: parentEl,
          targetEl: noteTitleEl,
          linktext: files[si].path
        });
      });
    }
    noteTitleEl.addEventListener("contextmenu", (event) => {
      const menu = new import_obsidian7.Menu();
      menu.addSeparator();
      if (checkFlag(srcFile, files[si], "top", this.settings)) {
        menu.addItem((item) => item.setTitle("MNO: Stop displaying at the top").setIcon("pin-off").onClick(() => __async(this, null, function* () {
          removeFlag(srcFile, files[si], "top", this.settings);
          yield this.plugin.saveSettings();
          yield this.refreshView(true, true);
        })));
      } else {
        menu.addItem((item) => item.setTitle("MNO: Always display at the top").setIcon("pin").onClick(() => __async(this, null, function* () {
          addFlag(srcFile, files[si], "top", this.settings);
          yield this.plugin.saveSettings();
          yield this.refreshView(true, true);
        })));
      }
      if (this.settings.favorite[noteType].includes(files[si].path)) {
        menu.addItem((item) => item.setTitle("MNO: Remove from favorites").setIcon("bookmark-minus").onClick(() => __async(this, null, function* () {
          deleteFavAndRecent.call(this, files[si].path, noteType, "favorite");
          yield this.plugin.saveSettings();
        })));
      } else {
        menu.addItem((item) => item.setTitle("MNO: Add to favorites").setIcon("bookmark-plus").onClick(() => __async(this, null, function* () {
          updateFavAndRecent.call(this, files[si].path, noteType, "favorite");
          yield this.plugin.saveSettings();
        })));
      }
      menu.addSeparator();
      if (noteType == "file") {
        menu.addItem((item) => item.setTitle("Open in new tab").setIcon("file-plus").onClick(() => {
          if (files[si] != this.activeFile) {
            this.holdUpdateOnce = true;
          }
          event.preventDefault();
          this.app.workspace.getLeaf("tab").openFile(files[si]);
        }));
        menu.addItem((item) => item.setTitle("Open to the right").setIcon("separator-vertical").onClick(() => {
          if (files[si] != this.activeFile) {
            this.holdUpdateOnce = true;
          }
          event.preventDefault();
          this.app.workspace.getLeaf("split").openFile(files[si]);
        }));
        menu.addItem((item) => item.setTitle("Open in new window").setIcon("scan").onClick(() => __async(this, null, function* () {
          if (files[si] != this.activeFile) {
            this.holdUpdateOnce = true;
          }
          yield this.app.workspace.openPopoutLeaf({
            size: {
              width: this.settings.popoutSize.width,
              height: this.settings.popoutSize.height
            }
          }).openFile(files[si]);
          if (this.settings.popoutAlwaysOnTop) {
            setPopoutAlwaysOnTop();
          }
        })));
      }
      menu.showAtMouseEvent(event);
    });
    if (!status[si].outlineReady) {
      noteEl.classList.add("is-collapsed");
      noteCollapseIcon.classList.add("is-collapsed");
      continue;
    }
    if (noteType == "folder") {
      constructNoteDOM.call(this, this.targetFiles[files[si].path], this.fileStatus[files[si].path], this.fileInfo[files[si].path], this.outlineData[files[si].path], noteChildrenEl, "folder", aotEl, srcFile, this.fileOrder[files[si].path]);
    } else {
      constructOutlineDOM.call(this, files[si], info[si], data[si], noteChildrenEl, category);
    }
    if (this.collapseAll || status[si].duplicated.main && this.settings.showFiles.main || status[si].duplicated.outgoing && this.settings.showFiles.outgoing || status[si].duplicated.self || ((_c = (_b = (_a = this.settings.relatedFiles) == null ? void 0 : _a[srcFile.path]) == null ? void 0 : _b[files[si].path]) == null ? void 0 : _c.fold)) {
      noteEl.classList.add("is-collapsed");
      noteCollapseIcon.classList.add("is-collapsed");
      status[si].isFolded = true;
      noteChildrenEl.style.display = "none";
    } else {
      status[si].isFolded = false;
    }
  }
}
function attachFileInfo(targetEl, status, info, data, displayFileInfo) {
  if (!status.isFolder) {
    switch (displayFileInfo) {
      case "lines":
        targetEl.dataset.subinfo = status.outlineReady ? info.numOfLines.toString() : "";
        break;
      case "tag":
        if (status.outlineReady) {
          const firsttagIndex = data.findIndex((element, index) => data[index].typeOfElement == "tag");
          if (firsttagIndex >= 0) {
            targetEl.dataset.subinfo = data[firsttagIndex].displayText;
          }
        }
        break;
      case "none":
        break;
      default:
        break;
    }
  }
}

// src/fileView.ts
var MultipleNotesOutlineViewType = "multiple-notes-outline";
var MultipleNotesOutlineView = class extends import_obsidian9.ItemView {
  constructor(leaf, plugin, settings) {
    super(leaf);
    this.targetFiles = {
      main: [],
      outgoing: [],
      backlink: []
    };
    this.fileStatus = {
      main: [],
      outgoing: [],
      backlink: []
    };
    this.fileInfo = {
      main: [],
      outgoing: [],
      backlink: []
    };
    this.outlineData = {
      main: [],
      outgoing: [],
      backlink: []
    };
    this.fileOrder = {
      main: [],
      outgoing: [],
      backlink: []
    };
    this.flagChanged = false;
    this.flagRegetTarget = false;
    this.flagSaveSettings = false;
    this.extractMode = false;
    this.extractTask = false;
    this.collapseAll = false;
    this.collapseCategory = {
      outgoing: false,
      backlink: false
    };
    this.holdUpdateOnce = false;
    this.hasMainChanged = false;
    this.filecount = 0;
    this.changedFiles = [];
    this.viewType = "file";
    this.pinnedMode = false;
    this.isDataviewEnabled = false;
    this.plugin = plugin;
    this.settings = settings;
  }
  getViewType() {
    return MultipleNotesOutlineViewType;
  }
  getDisplayText() {
    return "MNO - file view";
  }
  getIcon() {
    return "files";
  }
  onOpen() {
    return __async(this, null, function* () {
      yield this.initView();
    });
  }
  updateSettings() {
    this.settings = this.plugin.settings;
  }
  onClose() {
    return __async(this, null, function* () {
    });
  }
  initView() {
    return __async(this, null, function* () {
      var _a, _b, _c, _d;
      yield this.bootDelay();
      checkRelatedFiles(this.app, this.settings);
      checkFavAndRecentFiles(this.app, this.settings, this.viewType);
      this.collapseAll = this.settings.collapseAllAtStartup;
      this.theme = getTheme();
      setNoteTitleBackgroundColor(this.theme, this.settings);
      this.activeFile = this.app.workspace.getActiveFile();
      if (this.activeFile) {
        if (this.settings.openRecentAtStartup.file && this.app.vault.getAbstractFileByPath((_a = this.settings.recent.file) == null ? void 0 : _a[0]) instanceof import_obsidian9.TFile) {
          this.targetFiles.main[0] = this.app.vault.getAbstractFileByPath((_b = this.settings.recent.file) == null ? void 0 : _b[0]);
          if (this.settings.pinAfterJump && this.settings.autoupdateFileView) {
            this.pinnedMode = true;
          }
        } else {
          this.targetFiles.main[0] = this.activeFile;
        }
      } else {
        if (this.app.vault.getAbstractFileByPath((_c = this.settings.recent.file) == null ? void 0 : _c[0]) instanceof import_obsidian9.TFile) {
          this.targetFiles.main[0] = this.app.vault.getAbstractFileByPath((_d = this.settings.recent.file) == null ? void 0 : _d[0]);
          if (this.settings.pinAfterJump && this.settings.autoupdateFileView) {
            this.pinnedMode = true;
          }
        } else {
          this.targetFiles.main[0] = null;
        }
      }
      this.refreshView(true, true);
      const debouncerRequestRefresh = (0, import_obsidian8.debounce)(this.autoRefresh, 3e3, true);
      this.flagChanged = false;
      this.flagRegetTarget = false;
      this.registerEvent(this.app.workspace.on("file-open", (file) => {
        if (file instanceof import_obsidian9.TFile && file !== this.activeFile) {
          this.activeFile = file;
          if (!this.settings.autoupdateFileView || this.settings.suspendUpdateByClickingView && this.holdUpdateOnce || this.pinnedMode == true) {
          } else if (this.targetFiles.main[0].extension == "canvas" && this.targetFiles.outgoing.includes(this.activeFile)) {
          } else {
            this.targetFiles.main[0] = this.activeFile;
            this.hasMainChanged = true;
            updateFavAndRecent.call(this, this.activeFile.path, "file", "recent");
            this.refreshView(true, true);
          }
          this.holdUpdateOnce = false;
        }
      }));
      this.registerEvent(this.app.metadataCache.on("changed", (file) => {
        let category;
        for (category in this.targetFiles) {
          if (this.targetFiles[category].includes(file)) {
            if (!this.changedFiles.includes(file)) {
              this.changedFiles.push(file);
            }
            this.flagChanged = true;
            debouncerRequestRefresh.call(this);
            break;
          }
        }
      }));
      this.registerEvent(this.app.vault.on("delete", (file) => {
        if (file instanceof import_obsidian9.TFile) {
          if (file == this.activeFile && file != this.targetFiles.main[0]) {
            this.holdUpdateOnce = true;
          }
          const changedRelatedFiles = handleDeleteRelatedFiles(file, this.settings);
          if (changedRelatedFiles) {
            this.flagSaveSettings = true;
          }
          const changedFavAndRecent = handleDeleteFavAndRecentFiles(file, this.settings);
          if (changedFavAndRecent) {
            this.flagSaveSettings = true;
          }
          this.flagRegetTarget = true;
          debouncerRequestRefresh.call(this);
        }
      }));
      this.registerEvent(this.app.vault.on("rename", (file, oldPath) => {
        if (file instanceof import_obsidian9.TFile) {
          const changedRelatedFiles = handleRenameRelatedFiles(file, oldPath, this.settings);
          if (changedRelatedFiles) {
            this.flagSaveSettings = true;
          }
          const changedFavAndRecent = handleRenameFavAndRecentFiles(file, oldPath, this.settings);
          if (changedFavAndRecent) {
            this.flagSaveSettings = true;
          }
          this.flagRegetTarget = true;
          debouncerRequestRefresh.call(this);
        }
      }));
      this.registerEvent(this.app.workspace.on("css-change", (e) => {
        const newTheme = getTheme();
        if (newTheme !== this.theme) {
          this.theme = newTheme;
          setNoteTitleBackgroundColor(this.theme, this.settings);
        }
      }));
    });
  }
  bootDelay() {
    return __async(this, null, function* () {
      return new Promise((resolve) => {
        setTimeout(resolve, this.settings.bootDelayTime);
      });
    });
  }
  autoRefresh() {
    return __async(this, null, function* () {
      const startTime = performance.now();
      if (!(this.flagChanged || this.flagRegetTarget || this.flagSaveSettings)) {
        return;
      }
      if (this.flagChanged && !this.flagRegetTarget) {
        for (let i = 0; i < this.changedFiles.length; i++) {
          let category;
          for (category in this.targetFiles) {
            const index = this.targetFiles[category].indexOf(this.changedFiles[i]);
            if (index < 0) {
              continue;
            }
            this.fileInfo[category][index] = yield getFileInfo(this.app, this.targetFiles[category][index], this.settings, true, this.isDataviewEnabled);
            const newData = yield getOutline(this.app, this.targetFiles[category][index], this.fileStatus[category][index], this.fileInfo[category][index], this.settings);
            if (newData) {
              this.outlineData[category][index] = newData;
              this.fileStatus[category][index].outlineReady = true;
            }
            const updateNoteChildrenEl = document.getElementById("MNO" + this.viewType + this.targetFiles[category][index].path);
            updateNoteChildrenEl.empty();
            constructOutlineDOM.call(this, this.targetFiles[category][index], this.fileInfo[category][index], this.outlineData[category][index], updateNoteChildrenEl, category);
          }
        }
      }
      if (this.flagSaveSettings) {
        yield this.plugin.saveSettings();
      }
      if (this.flagRegetTarget) {
        yield this.refreshView(this.flagRegetTarget, this.flagRegetTarget);
      }
      this.changedFiles = [];
      this.flagRegetTarget = false;
      this.flagChanged = false;
      this.flagSaveSettings = false;
      const endTime = performance.now();
      if (this.settings.showDebugInfo) {
        console.log("Multiple Notes Outline: time required to auto refresh, file view: ", endTime - startTime);
      }
    });
  }
  refreshView(flagGetTarget, flagGetOutline) {
    return __async(this, null, function* () {
      var _a;
      const startTime = performance.now();
      this.isDataviewEnabled = checkDataview(this.app);
      const containerEl = document.getElementById("MNOfileview-listcontainer");
      const previousY = (containerEl == null ? void 0 : containerEl.scrollTop) ? containerEl.scrollTop : 0;
      if (!this.targetFiles.main[0]) {
        drawUI.call(this);
        return;
      }
      this.filecount = 0;
      if (this.targetFiles.main[0] && flagGetTarget) {
        this.fileStatus.main = initFileStatus(this.targetFiles.main);
        this.fileOrder.main = [...Array(this.targetFiles.main.length)].map((_, i) => i);
        [this.fileStatus.main, this.fileInfo.main, this.outlineData.main] = yield this.getOutlines(this.targetFiles.main, this.fileStatus.main);
        this.targetFiles.outgoing = getOutgoingLinkFiles(this.app, this.targetFiles.main[0], this.fileInfo.main[0], this.outlineData.main[0]);
        this.fileStatus.outgoing = initFileStatus(this.targetFiles.outgoing);
        this.fileOrder.outgoing = [...Array(this.targetFiles.outgoing.length)].map((_, i) => i);
        this.targetFiles.backlink = (_a = this.fileInfo.main[0]) == null ? void 0 : _a.backlinks;
        this.fileStatus.backlink = initFileStatus(this.targetFiles.backlink);
        this.fileOrder.backlink = [...Array(this.targetFiles.backlink.length)].map((_, i) => i);
        this.checkDuplicated(this.targetFiles.outgoing, this.targetFiles.main, "main", this.fileStatus.outgoing);
        this.checkDuplicated(this.targetFiles.outgoing, this.targetFiles.outgoing, "self", this.fileStatus.outgoing);
        this.checkDuplicated(this.targetFiles.backlink, this.targetFiles.main, "main", this.fileStatus.backlink);
        this.checkDuplicated(this.targetFiles.backlink, this.targetFiles.outgoing, "outgoing", this.fileStatus.backlink);
        this.checkDuplicated(this.targetFiles.backlink, this.targetFiles.backlink, "self", this.fileStatus.backlink);
      }
      if (flagGetOutline && this.targetFiles.outgoing.length + this.targetFiles.backlink.length <= this.settings.processLimit) {
        [this.fileStatus.outgoing, this.fileInfo.outgoing, this.outlineData.outgoing] = yield this.getOutlines(this.targetFiles.outgoing, this.fileStatus.outgoing);
        [this.fileStatus.backlink, this.fileInfo.backlink, this.outlineData.backlink] = yield this.getOutlines(this.targetFiles.backlink, this.fileStatus.backlink);
        sortFileOrder(this.fileOrder.backlink, this.targetFiles.backlink, this.fileStatus.backlink, this.fileInfo.backlink, this.settings);
      }
      const midTime = performance.now();
      if (this.settings.showDebugInfo) {
        console.log("Multiple Notes Outline: time required to get outlines, file view: ", this.targetFiles.main[0].path, midTime - startTime);
      }
      drawUI.call(this);
      this.drawOutline(previousY);
      const endTime = performance.now();
      if (this.settings.showDebugInfo) {
        console.log("Multiple Notes Outline: time required to draw outlines, file view: ", this.targetFiles.main[0].path, endTime - midTime, previousY);
        console.log("Multiple Notes Outline: time required to refresh view, file view", this.targetFiles.main[0].path, endTime - startTime);
      }
    });
  }
  getOutlines(files, status) {
    return __async(this, null, function* () {
      const fileInfo = [];
      const outlineData = [];
      for (let i = 0; i < files.length; i++) {
        if (checkFlag(this.targetFiles.main[0], files[i], "top", this.settings) == true) {
          status[i].isTop = true;
        }
        if ((this.filecount < this.settings.readLimit || status[i].isTop) && !Object.values(status[i].duplicated).includes(true)) {
          const info = yield getFileInfo(this.app, files[i], this.settings, Boolean(files.length == 1), this.isDataviewEnabled);
          fileInfo.push(info);
          const data = yield getOutline(this.app, files[i], status[i], info, this.settings);
          if (data) {
            outlineData.push(data);
            status[i].outlineReady = true;
          } else {
            outlineData.push(void 0);
          }
        } else {
          fileInfo.push(void 0);
          outlineData.push(void 0);
        }
        this.filecount++;
      }
      return [status, fileInfo, outlineData];
    });
  }
  drawOutline(previousY) {
    const containerEl = createDiv("nav-files-container node-insert-event");
    const rootEl = containerEl.createDiv("tree-item nav-folder mod-root");
    const rootChildrenEl = rootEl.createDiv("tree-item-children nav-folder-children");
    containerEl.id = "MNOfileview-listcontainer";
    const categoryAOTEl = rootChildrenEl.createDiv("tree-item nav-folder mod-root");
    if (this.settings.showFiles.main) {
      const categoryMainEl = rootChildrenEl.createDiv("tree-item nav-folder mod-root");
      constructNoteDOM.call(this, this.targetFiles.main, this.fileStatus.main, this.fileInfo.main, this.outlineData.main, categoryMainEl, "main", categoryAOTEl, this.targetFiles.main[0], this.fileOrder.main);
    }
    if (this.settings.showFiles.outgoing) {
      this.constructCategoryDOM("outgoing", "links-going-out", "Outgoing Link Files", rootChildrenEl, categoryAOTEl);
    }
    if (this.settings.showFiles.backlink) {
      this.constructCategoryDOM("backlink", "links-coming-in", "Backlink Files", rootChildrenEl, categoryAOTEl);
    }
    this.contentEl.appendChild(containerEl);
    if (this.hasMainChanged == false && previousY != 0) {
      containerEl.scrollTop = previousY;
    }
    this.hasMainChanged = false;
  }
  constructCategoryDOM(category, cIcon, cText, parentEl, aotEl) {
    const categoryEl = parentEl.createDiv("tree-item nav-folder");
    const categoryTitleEl = categoryEl.createDiv("tree-item-self is-clickable mod-collapsible nav-folder-title");
    (0, import_obsidian8.setIcon)(categoryTitleEl, cIcon);
    categoryTitleEl.createDiv("tree-item-inner nav-folder-title-content").setText(cText);
    const categoryCollapseIcon = categoryTitleEl.createDiv("tree-item-icon collapse-icon nav-folder-collapse-indicator");
    (0, import_obsidian8.setIcon)(categoryCollapseIcon, "right-triangle");
    categoryCollapseIcon.addEventListener("click", (event) => __async(this, null, function* () {
      event.stopPropagation();
      if (this.collapseCategory[category]) {
        this.collapseCategory[category] = false;
        this.refreshView(false, false);
      } else {
        this.collapseCategory[category] = true;
        categoryEl.classList.add("is-collapsed");
        categoryCollapseIcon.classList.add("is-collapsed");
        categoryChildrenEl.style.display = "none";
      }
    }));
    const categoryChildrenEl = categoryEl.createDiv("tree-item-children nav-folder-children");
    if (!this.collapseCategory[category]) {
      constructNoteDOM.call(this, this.targetFiles[category], this.fileStatus[category], this.fileInfo[category], this.outlineData[category], categoryChildrenEl, category, aotEl, this.targetFiles.main[0], this.fileOrder[category]);
    } else {
      categoryEl.classList.add("is-collapsed");
      categoryCollapseIcon.classList.add("is-collapsed");
    }
  }
  checkDuplicated(files, compare, category, status) {
    fileloop:
      for (let i = 0; i < files.length; i++) {
        for (let j = 0; j < compare.length; j++) {
          if (category == "self" && j >= i) {
            break;
          }
          if (compare[j].path === files[i].path) {
            status[i].duplicated[category] = true;
            continue fileloop;
          }
        }
      }
    return status;
  }
};

// src/setting.ts
var import_obsidian10 = __toModule(require("obsidian"));
var MultipleNotesOutlineSettingTab = class extends import_obsidian10.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian10.Setting(containerEl).setName("Show headings").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showElements.heading).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.showElements.heading = value;
        this.display();
        yield this.plugin.saveSettings();
        this.callRefreshView(false);
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Show links").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showElements.link).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.showElements.link = value;
        this.display();
        yield this.plugin.saveSettings();
        this.callRefreshView(false);
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Show tags").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showElements.tag).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.showElements.tag = value;
        this.display();
        yield this.plugin.saveSettings();
        this.callRefreshView(false);
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Show list items & tasks").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showElements.listItems).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.showElements.listItems = value;
        this.display();
        yield this.plugin.saveSettings();
        this.callRefreshView(false);
      }));
    });
    if (this.plugin.settings.showElements.listItems) {
      new import_obsidian10.Setting(containerEl).setName("Show all root list items").setDesc("if disabled, only top item of the list is displayed").setClass("setting-indent").addToggle((toggle) => {
        toggle.setValue(this.plugin.settings.allRootItems).onChange((value) => __async(this, null, function* () {
          this.plugin.settings.allRootItems = value;
          this.display();
          yield this.plugin.saveSettings();
          this.callRefreshView(false);
        }));
      });
      new import_obsidian10.Setting(containerEl).setName("Show all tasks").setDesc("show all task items regardless of their level").setClass("setting-indent").addToggle((toggle) => {
        toggle.setValue(this.plugin.settings.allTasks).onChange((value) => __async(this, null, function* () {
          this.plugin.settings.allTasks = value;
          this.display();
          yield this.plugin.saveSettings();
          this.callRefreshView(false);
        }));
      });
      new import_obsidian10.Setting(containerEl).setName("Task only").setDesc("if enabled, normal list items are hidden").setClass("setting-indent").addToggle((toggle) => {
        toggle.setValue(this.plugin.settings.taskOnly).onChange((value) => __async(this, null, function* () {
          this.plugin.settings.taskOnly = value;
          this.display();
          yield this.plugin.saveSettings();
          this.callRefreshView(false);
        }));
      });
      new import_obsidian10.Setting(containerEl).setName("Hide completed tasks").setClass("setting-indent").addToggle((toggle) => {
        toggle.setValue(this.plugin.settings.hideCompletedTasks).onChange((value) => __async(this, null, function* () {
          this.plugin.settings.hideCompletedTasks = value;
          this.display();
          yield this.plugin.saveSettings();
          this.callRefreshView(false);
        }));
      });
      new import_obsidian10.Setting(containerEl).setName("Show list callouts").setDesc("shows list items marked with List Callouts plugin").setClass("setting-indent").addToggle((toggle) => {
        toggle.setValue(this.plugin.settings.dispListCallouts).onChange((value) => __async(this, null, function* () {
          this.plugin.settings.dispListCallouts = value;
          this.display();
          yield this.plugin.saveSettings();
          this.callRefreshView(false);
        }));
      });
    }
    new import_obsidian10.Setting(containerEl).setName("Show backlink files").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showBacklinks).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.showBacklinks = value;
        this.display();
        yield this.plugin.saveSettings();
        this.callRefreshView(false);
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Collapse all at startup").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.collapseAllAtStartup).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.collapseAllAtStartup = value;
        this.display();
        yield this.plugin.saveSettings();
        this.callRefreshView(false);
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Display file information").setDesc("display the number of lines of the file / the first tag with the file name").addDropdown((dropdown) => {
      dropdown.addOption("none", "none").addOption("lines", "lines of the note").addOption("tag", "first tag").setValue(this.plugin.settings.displayFileInfo).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.displayFileInfo = value;
        this.display();
        yield this.plugin.saveSettings();
        this.callRefreshView(false);
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Position of the plugin view").setDesc("Specify default position where this plugin's view appears").addDropdown((dropdown) => {
      dropdown.addOption("right", "right side pane").addOption("left", "left side pane").addOption("tab", "new tab in main pane").addOption("split", "splitted pane").addOption("popout", "popout window").setValue(this.plugin.settings.viewPosition).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.viewPosition = value;
        this.display();
        yield this.plugin.saveSettings();
        this.callRefreshView(false);
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Sort type").setDesc("Specify sort order").addDropdown((dropdown) => {
      dropdown.addOption("alphabetAscending", "File name (A to Z)").addOption("alphabetDescending", "File name (Z to A)").addOption("mtimeDescending", "Modified time (new to old) ").addOption("mtimeAscending", "Modified time (old to new) ").addOption("ctimeDescending", "Created time (new to old) ").addOption("ctimeAscending", "Created time (old to new) ").setValue(this.plugin.settings.sortType).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.sortType = value;
        this.display();
        yield this.plugin.saveSettings();
        this.callRefreshView(true);
      }));
    });
    this.containerEl.createEl("h4", {
      text: "File View",
      cls: "setting-category"
    });
    new import_obsidian10.Setting(containerEl).setName("Open File View at startup").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.openAtStartup.file).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.openAtStartup.file = value;
        this.display();
        yield this.plugin.saveSettings();
        this.callRefreshView(false);
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Open last view at startup").setDesc("If enabled, the most recently opened view is opened when File View is launched.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.openRecentAtStartup.file).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.openRecentAtStartup.file = value;
        this.display();
        yield this.plugin.saveSettings();
        this.callRefreshView(false);
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Show the main target file section").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showFiles.main).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.showFiles.main = value;
        this.display();
        yield this.plugin.saveSettings();
        this.callRefreshView(false);
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Show the the outgoing files section").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showFiles.outgoing).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.showFiles.outgoing = value;
        this.display();
        yield this.plugin.saveSettings();
        this.callRefreshView(false);
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Show the the backlink files section").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showFiles.backlink).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.showFiles.backlink = value;
        this.display();
        yield this.plugin.saveSettings();
        this.callRefreshView(false);
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Update File View when another file becomes active").setDesc("Automatically update the view when another file becomes active(default = on). The view is not updated if the transition is made via clicking on the MNO view items.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.autoupdateFileView).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.autoupdateFileView = value;
        this.display();
        yield this.plugin.saveSettings();
      }));
    });
    if (this.plugin.settings.autoupdateFileView) {
      new import_obsidian10.Setting(containerEl).setName("Suspend update by clicking on view item").setClass("setting-indent").setDesc("suspend updating the view when the active file is changed by clicking on items in the File View(default = on)").addToggle((toggle) => {
        toggle.setValue(this.plugin.settings.suspendUpdateByClickingView).onChange((value) => __async(this, null, function* () {
          this.plugin.settings.suspendUpdateByClickingView = value;
          this.display();
          yield this.plugin.saveSettings();
        }));
      });
    }
    new import_obsidian10.Setting(containerEl).setName("Hide duplicate notes").setDesc("hides notes that appear multiple times in the outline.(default = on)").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.hideDuplicated).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.hideDuplicated = value;
        this.display();
        yield this.plugin.saveSettings();
        this.callRefreshView(false);
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Hide link elements between displayed files").setDesc("main file only: hide links between the main file and other displayed. other files to main file only: hide links from other displayed files to the main file. all: hide links between all displayed files.").addDropdown((dropdown) => {
      dropdown.addOption("none", "none").addOption("mainOnly", "main file only").addOption("toMainOnly", "other files to main file only").addOption("all", "all").setValue(this.plugin.settings.hideLinksBetweenRelatedFiles).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.hideLinksBetweenRelatedFiles = value;
        this.display();
        yield this.plugin.saveSettings();
        this.callRefreshView(false);
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Hide minor 2 hop links").setDesc("hides outgoing links in outgoing files section and backlinks in backlink files section.(default = off)").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.hideMinor2hopLink).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.hideMinor2hopLink = value;
        this.display();
        yield this.plugin.saveSettings();
        this.callRefreshView(false);
      }));
    });
    this.containerEl.createEl("h4", {
      text: "Folder View",
      cls: "setting-category"
    });
    new import_obsidian10.Setting(containerEl).setName("Open Folder View at startup").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.openAtStartup.folder).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.openAtStartup.folder = value;
        this.display();
        yield this.plugin.saveSettings();
        this.callRefreshView(false);
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Open last view at startup").setDesc("If enabled, the most recently opened view is opened when Folder View is launched.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.openRecentAtStartup.folder).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.openRecentAtStartup.folder = value;
        this.display();
        yield this.plugin.saveSettings();
        this.callRefreshView(false);
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Collapse subfolder").setDesc("display subfolders in collapsed state").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.collapseFolder).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.collapseFolder = value;
        this.display();
        yield this.plugin.saveSettings();
        this.callRefreshView(false);
      }));
    });
    this.containerEl.createEl("h4", {
      text: "Headings",
      cls: "setting-category"
    });
    if (this.plugin.settings.showElements.heading) {
      new import_obsidian10.Setting(containerEl).setName("Max heading level to display").setDesc("specify the maximum heading level to display").addDropdown((dropdown) => {
        dropdown.addOption("1", "1 #").addOption("2", "2 ##").addOption("3", "3 ###").addOption("4", "4 ####").addOption("5", "5 #####").addOption("6", "6 ######").setValue(String(this.plugin.settings.maxHeadingLevel)).onChange((value) => __async(this, null, function* () {
          this.plugin.settings.maxHeadingLevel = Number(value);
          this.display();
          yield this.plugin.saveSettings();
          this.callRefreshView(false);
        }));
      });
    } else {
      this.containerEl.createEl("p", {
        text: "To display this section, activate 'Show headings' in Basics section.",
        cls: "setting-item-description"
      });
    }
    this.containerEl.createEl("h4", {
      text: "Links",
      cls: "setting-category"
    });
    new import_obsidian10.Setting(containerEl).setName("Open link by clicking link element").setDesc("If enabled, clicking on a link element opens the linked file instead of opening the element's position.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.openLinkByClick).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.openLinkByClick = value;
        this.display();
        yield this.plugin.saveSettings();
      }));
    });
    this.containerEl.createEl("h4", {
      text: "Preview"
    });
    new import_obsidian10.Setting(containerEl).setName("Inline preview").setDesc("Show a few subsequent words next to the outline element name").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.inlinePreview).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.inlinePreview = value;
        this.display();
        yield this.plugin.saveSettings();
        this.callRefreshView(false);
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Tooltip preview").setDesc("Show subsequent sentences as a tooltip when hover").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.tooltipPreview).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.tooltipPreview = value;
        this.display();
        yield this.plugin.saveSettings();
        this.callRefreshView(false);
      }));
    });
    if (this.plugin.settings.tooltipPreview) {
      new import_obsidian10.Setting(containerEl).setName("Tooltip preview direction").setClass("setting-indent").setDesc("specify the direction to display tooltip preview").addDropdown((dropdown) => {
        dropdown.addOption("left", "left").addOption("right", "right").addOption("bottom", "bottom").addOption("top", "top").setValue(this.plugin.settings.tooltipPreviewDirection).onChange((value) => __async(this, null, function* () {
          this.plugin.settings.tooltipPreviewDirection = value;
          this.display();
          yield this.plugin.saveSettings();
          this.callRefreshView(false);
        }));
      });
    }
    this.containerEl.createEl("h4", {
      text: "Popout window",
      cls: "setting-category"
    });
    this.containerEl.createEl("p", {
      text: "Popout window size",
      cls: "setting-category"
    });
    new import_obsidian10.Setting(containerEl).setName("Width").setDesc("default & min = 600").addText((text) => {
      text.inputEl.setAttr("type", "number");
      text.setPlaceholder(String(DEFAULT_SETTINGS.popoutSize.width)).setValue(String(this.plugin.settings.popoutSize.width));
      text.inputEl.onblur = (e) => __async(this, null, function* () {
        let parsed = parseInt(e.target.value, 10);
        if (parsed <= 600) {
          parsed = DEFAULT_SETTINGS.popoutSize.width;
        }
        this.plugin.settings.popoutSize.width = parsed;
        yield this.plugin.saveSettings();
      });
    });
    new import_obsidian10.Setting(containerEl).setName("Height").setDesc("default = 800 min = 600").addText((text) => {
      text.inputEl.setAttr("type", "number");
      text.setPlaceholder(String(DEFAULT_SETTINGS.popoutSize.height)).setValue(String(this.plugin.settings.popoutSize.height));
      text.inputEl.onblur = (e) => __async(this, null, function* () {
        let parsed = parseInt(e.target.value, 10);
        if (parsed <= 600) {
          parsed = DEFAULT_SETTINGS.popoutSize.height;
        }
        this.plugin.settings.popoutSize.height = parsed;
        yield this.plugin.saveSettings();
      });
    });
    new import_obsidian10.Setting(containerEl).setName("Set popout window always on top").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.popoutAlwaysOnTop).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.popoutAlwaysOnTop = value;
        this.display();
        yield this.plugin.saveSettings();
      }));
    });
    this.containerEl.createEl("h4", {
      text: "Always on top",
      cls: "setting-category"
    });
    new import_obsidian10.Setting(containerEl).setName("Tags").setDesc("Notes with tags which match listed words are displayed on the top of the list. Separate with a new line.").addTextArea((textArea) => {
      textArea.setValue(this.plugin.settings.tagsAOT.join("\n"));
      textArea.inputEl.onblur = (e) => __async(this, null, function* () {
        const inputedValue = e.target.value;
        this.plugin.settings.tagsAOT = inputedValue.split("\n");
        yield this.plugin.saveSettings();
        this.callRefreshView(false);
      });
    });
    this.containerEl.createEl("h4", {
      text: "Recent/favorites",
      cls: "setting-category"
    });
    new import_obsidian10.Setting(containerEl).setName("Number of recent files/folders to be stored").addText((text) => {
      text.inputEl.setAttr("type", "number");
      text.setPlaceholder(String(DEFAULT_SETTINGS.numOfRecentFiles)).setValue(String(this.plugin.settings.numOfRecentFiles));
      text.inputEl.onblur = (e) => __async(this, null, function* () {
        let parsed = parseInt(e.target.value, 10);
        if (parsed <= 0) {
          parsed = DEFAULT_SETTINGS.numOfRecentFiles;
        }
        this.plugin.settings.numOfRecentFiles = parsed;
        yield this.plugin.saveSettings();
      });
    });
    new import_obsidian10.Setting(containerEl).setName("Auto pin").setDesc("When File View is updated from recent/favorite files, automatically pin the view.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.pinAfterJump).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.pinAfterJump = value;
        this.display();
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Save recent view").setDesc("If disabled, the history of views displayed will not be saved sequentially. History is sometimes lost, but the frequency of data.json rewriting and subsequent synchronization is reduced.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.saveRecentView).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.saveRecentView = value;
        this.display();
        yield this.plugin.saveSettings();
      }));
    });
    this.containerEl.createEl("h4", {
      text: "Appearnce",
      cls: "setting-category"
    });
    new import_obsidian10.Setting(containerEl).setName("Wrap outline element text").setDesc("If enabled, long element names are displayed wrapped on multiple lines").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.wrapLine).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.wrapLine = value;
        this.display();
        yield this.plugin.saveSettings();
        this.callRefreshView(false);
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Indent other than headings").setDesc("Whether other elements should be indented to preceding headings (default = preceding heading +1)").addDropdown((dropdown) => {
      dropdown.addOption("0", "none").addOption("1", "follow preceding heading").addOption("2", "preceding heading + 1").setValue(String(this.plugin.settings.indentFollowHeading)).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.indentFollowHeading = Number(value);
        this.display();
        yield this.plugin.saveSettings();
        this.callRefreshView(false);
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Note title background color").setDesc("No change: use the current CSS theme setting values(Texts may be overlapped). Same as outlines: default theme explorer color. Accent: highlight file names. Custom: Specify any color code. Please update the view when you toggled Obsidian's base theme(light/dark). (default = accent)").addDropdown((dropdown) => {
      dropdown.addOption("none", "no change").addOption("default", "same as outlines").addOption("accent", "accent").addOption("custom", "custom").setValue(this.plugin.settings.noteTitleBackgroundColor).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.noteTitleBackgroundColor = value;
        this.display();
        yield this.plugin.saveSettings();
        this.callRefreshView(false);
      }));
    });
    if (this.plugin.settings.noteTitleBackgroundColor == "custom") {
      new import_obsidian10.Setting(containerEl).setName("Custom note title background color (light)").setClass("setting-indent").setDesc("Specify background color (ex. #FFFFFF or rgb(255,255,255))").addText((text) => {
        text.inputEl.setAttr("type", "string");
        text.setValue(this.plugin.settings.customNoteTitleBackgroundColor.light);
        text.inputEl.onblur = (e) => __async(this, null, function* () {
          const inputedValue = e.target.value;
          this.plugin.settings.customNoteTitleBackgroundColor.light = inputedValue;
          yield this.plugin.saveSettings();
          this.callRefreshView(false);
        });
      });
      new import_obsidian10.Setting(containerEl).setName("Custom note title background color (light, on hover)").setClass("setting-indent").setDesc("Specify background color on hover (ex. #FFFFFF or rgb(255,255,255))").addText((text) => {
        text.inputEl.setAttr("type", "string");
        text.setValue(this.plugin.settings.customNoteTitleBackgroundColorHover.light);
        text.inputEl.onblur = (e) => __async(this, null, function* () {
          const inputedValue = e.target.value;
          this.plugin.settings.customNoteTitleBackgroundColorHover.light = inputedValue;
          yield this.plugin.saveSettings();
          this.callRefreshView(false);
        });
      });
      new import_obsidian10.Setting(containerEl).setName("Custom note title background color (dark)").setClass("setting-indent").setDesc("Specify background color (ex. #FFFFFF or rgb(255,255,255))").addText((text) => {
        text.inputEl.setAttr("type", "string");
        text.setValue(this.plugin.settings.customNoteTitleBackgroundColor.dark);
        text.inputEl.onblur = (e) => __async(this, null, function* () {
          const inputedValue = e.target.value;
          this.plugin.settings.customNoteTitleBackgroundColor.dark = inputedValue;
          yield this.plugin.saveSettings();
          this.callRefreshView(false);
        });
      });
      new import_obsidian10.Setting(containerEl).setName("Custom note title background color (dark, on hover)").setClass("setting-indent").setDesc("Specify background color on hover (ex. #FFFFFF or rgb(255,255,255))").addText((text) => {
        text.inputEl.setAttr("type", "string");
        text.setValue(this.plugin.settings.customNoteTitleBackgroundColorHover.dark);
        text.inputEl.onblur = (e) => __async(this, null, function* () {
          const inputedValue = e.target.value;
          this.plugin.settings.customNoteTitleBackgroundColorHover.dark = inputedValue;
          yield this.plugin.saveSettings();
          this.callRefreshView(false);
        });
      });
    }
    if (this.plugin.settings.showElements.heading) {
      this.containerEl.createEl("p", {
        text: "Headings",
        cls: "setting-category"
      });
      new import_obsidian10.Setting(containerEl).setName("Icon").setClass("setting-indent").addDropdown((dropdown) => {
        dropdown.addOption("none", "none").addOption("heading", "heading").addOption("hash", "hash").addOption("chevron-right", "chevron-right").addOption("headingwithnumber", "heading with number").addOption("custom", "custom").setValue(this.plugin.settings.icon.heading).onChange((value) => __async(this, null, function* () {
          this.plugin.settings.icon.heading = value;
          this.display();
          yield this.plugin.saveSettings();
          this.callRefreshView(false);
        }));
      });
      if (this.plugin.settings.icon.heading == "custom") {
        new import_obsidian10.Setting(containerEl).setName("Custom icon").setClass("setting-indent-2").setDesc("enter Lucide Icon name").addText((text) => {
          text.inputEl.setAttr("type", "string");
          text.setPlaceholder(DEFAULT_SETTINGS.customIcon.heading).setValue(this.plugin.settings.customIcon.heading);
          text.inputEl.onblur = (e) => __async(this, null, function* () {
            const inputedValue = e.target.value;
            this.plugin.settings.customIcon.heading = inputedValue;
            yield this.plugin.saveSettings();
            this.callRefreshView(false);
          });
        });
      }
      new import_obsidian10.Setting(containerEl).setName("Prefix").setClass("setting-indent").addText((text) => {
        text.inputEl.setAttr("type", "string");
        text.setPlaceholder(DEFAULT_SETTINGS.prefix.heading).setValue(this.plugin.settings.prefix.heading);
        text.inputEl.onblur = (e) => __async(this, null, function* () {
          const inputedValue = e.target.value;
          this.plugin.settings.prefix.heading = inputedValue;
          this.display();
          yield this.plugin.saveSettings();
          this.callRefreshView(false);
        });
      });
      if (this.plugin.settings.prefix.heading != "") {
        new import_obsidian10.Setting(containerEl).setName("Repeat heading prefix").setClass("setting-indent-2").addDropdown((dropdown) => {
          dropdown.addOption("none", "none").addOption("level", "as many times as its level").addOption("levelminus1", "level - 1").setValue(this.plugin.settings.repeatHeadingPrefix).onChange((value) => __async(this, null, function* () {
            this.plugin.settings.repeatHeadingPrefix = value;
            this.display();
            yield this.plugin.saveSettings();
            this.callRefreshView(false);
          }));
        });
      }
      new import_obsidian10.Setting(containerEl).setName("Add indent").setClass("setting-indent").addToggle((toggle) => {
        toggle.setValue(this.plugin.settings.indent.heading).onChange((value) => __async(this, null, function* () {
          this.plugin.settings.indent.heading = value;
          this.display();
          yield this.plugin.saveSettings();
          this.callRefreshView(false);
        }));
      });
    }
    if (this.plugin.settings.showElements.link) {
      this.containerEl.createEl("p", {
        text: "Links",
        cls: "setting-category"
      });
      new import_obsidian10.Setting(containerEl).setName("Icon").setClass("setting-indent").addDropdown((dropdown) => {
        dropdown.addOption("none", "none").addOption("link", "link").addOption("link-2", "link-2").addOption("custom", "custom").setValue(this.plugin.settings.icon.link).onChange((value) => __async(this, null, function* () {
          this.plugin.settings.icon.link = value;
          this.display();
          yield this.plugin.saveSettings();
          this.callRefreshView(false);
        }));
      });
      if (this.plugin.settings.icon.link == "custom") {
        new import_obsidian10.Setting(containerEl).setName("Custom icon").setClass("setting-indent-2").setDesc("enter Lucide Icon name").addText((text) => {
          text.inputEl.setAttr("type", "string");
          text.setPlaceholder(DEFAULT_SETTINGS.customIcon.link).setValue(this.plugin.settings.customIcon.link);
          text.inputEl.onblur = (e) => __async(this, null, function* () {
            const inputedValue = e.target.value;
            this.plugin.settings.customIcon.link = inputedValue;
            yield this.plugin.saveSettings();
            this.callRefreshView(false);
          });
        });
      }
      new import_obsidian10.Setting(containerEl).setName("Prefix").setClass("setting-indent").addText((text) => {
        text.inputEl.setAttr("type", "string");
        text.setPlaceholder(DEFAULT_SETTINGS.prefix.link).setValue(this.plugin.settings.prefix.link);
        text.inputEl.onblur = (e) => __async(this, null, function* () {
          const inputedValue = e.target.value;
          this.plugin.settings.prefix.link = inputedValue;
          this.display();
          yield this.plugin.saveSettings();
          this.callRefreshView(false);
        });
      });
    }
    if (this.plugin.settings.showElements.tag) {
      this.containerEl.createEl("p", {
        text: "Tags",
        cls: "setting-category"
      });
      new import_obsidian10.Setting(containerEl).setName("Icon").setClass("setting-indent").addDropdown((dropdown) => {
        dropdown.addOption("none", "none").addOption("tag", "tag").addOption("hash", "hash").addOption("custom", "custom").setValue(this.plugin.settings.icon.tag).onChange((value) => __async(this, null, function* () {
          this.plugin.settings.icon.tag = value;
          this.display();
          yield this.plugin.saveSettings();
          this.callRefreshView(false);
        }));
      });
      if (this.plugin.settings.icon.tag == "custom") {
        new import_obsidian10.Setting(containerEl).setName("Custom icon").setClass("setting-indent-2").setDesc("enter Lucide Icon name").addText((text) => {
          text.inputEl.setAttr("type", "string");
          text.setPlaceholder(DEFAULT_SETTINGS.customIcon.tag).setValue(this.plugin.settings.customIcon.tag);
          text.inputEl.onblur = (e) => __async(this, null, function* () {
            const inputedValue = e.target.value;
            this.plugin.settings.customIcon.tag = inputedValue;
            yield this.plugin.saveSettings();
            this.callRefreshView(false);
          });
        });
      }
      new import_obsidian10.Setting(containerEl).setName("Prefix").setClass("setting-indent").addText((text) => {
        text.inputEl.setAttr("type", "string");
        text.setPlaceholder(DEFAULT_SETTINGS.prefix.tag).setValue(this.plugin.settings.prefix.tag);
        text.inputEl.onblur = (e) => __async(this, null, function* () {
          const inputedValue = e.target.value;
          this.plugin.settings.prefix.tag = inputedValue;
          this.display();
          yield this.plugin.saveSettings();
          this.callRefreshView(false);
        });
      });
    }
    if (this.plugin.settings.showElements.link) {
      this.containerEl.createEl("p", {
        text: "List items",
        cls: "setting-category"
      });
      new import_obsidian10.Setting(containerEl).setName("Icon").setClass("setting-indent").addDropdown((dropdown) => {
        dropdown.addOption("none", "none").addOption("list", "list").addOption("chevron-right", "chevron-right").addOption("minus", "minus").addOption("circle-dot", "circle-dot").addOption("asterisk", "asterisk").addOption("custom", "custom").setValue(this.plugin.settings.icon.listItems).onChange((value) => __async(this, null, function* () {
          this.plugin.settings.icon.listItems = value;
          this.display();
          yield this.plugin.saveSettings();
          this.callRefreshView(false);
        }));
      });
      if (this.plugin.settings.icon.listItems == "custom") {
        new import_obsidian10.Setting(containerEl).setName("Custom icon").setClass("setting-indent-2").setDesc("enter Lucide Icon name").addText((text) => {
          text.inputEl.setAttr("type", "string");
          text.setPlaceholder(DEFAULT_SETTINGS.customIcon.listItems).setValue(this.plugin.settings.customIcon.listItems);
          text.inputEl.onblur = (e) => __async(this, null, function* () {
            const inputedValue = e.target.value;
            this.plugin.settings.customIcon.listItems = inputedValue;
            yield this.plugin.saveSettings();
            this.callRefreshView(false);
          });
        });
      }
      new import_obsidian10.Setting(containerEl).setName("Prefix").setClass("setting-indent").addText((text) => {
        text.inputEl.setAttr("type", "string");
        text.setPlaceholder(DEFAULT_SETTINGS.prefix.listItems).setValue(this.plugin.settings.prefix.listItems);
        text.inputEl.onblur = (e) => __async(this, null, function* () {
          const inputedValue = e.target.value;
          this.plugin.settings.prefix.listItems = inputedValue;
          this.display();
          yield this.plugin.saveSettings();
          this.callRefreshView(false);
        });
      });
      this.containerEl.createEl("p", {
        text: "Tasks",
        cls: "setting-category"
      });
      new import_obsidian10.Setting(containerEl).setName("Icon").setClass("setting-indent").addDropdown((dropdown) => {
        dropdown.addOption("none", "none").addOption("square", "square").addOption("circle", "circle").addOption("list-checks", "list-checks").addOption("custom", "custom").setValue(this.plugin.settings.icon.task).onChange((value) => __async(this, null, function* () {
          this.plugin.settings.icon.task = value;
          this.display();
          yield this.plugin.saveSettings();
          this.callRefreshView(false);
        }));
      });
      if (this.plugin.settings.icon.task == "custom") {
        new import_obsidian10.Setting(containerEl).setName("Custom icon").setClass("setting-indent-2").setDesc("enter Lucide Icon name").addText((text) => {
          text.inputEl.setAttr("type", "string");
          text.setPlaceholder(DEFAULT_SETTINGS.customIcon.task).setValue(this.plugin.settings.customIcon.task);
          text.inputEl.onblur = (e) => __async(this, null, function* () {
            const inputedValue = e.target.value;
            this.plugin.settings.customIcon.task = inputedValue;
            yield this.plugin.saveSettings();
            this.callRefreshView(false);
          });
        });
      }
      new import_obsidian10.Setting(containerEl).setName("Prefix").setClass("setting-indent").addText((text) => {
        text.inputEl.setAttr("type", "string");
        text.setPlaceholder(DEFAULT_SETTINGS.prefix.task).setValue(this.plugin.settings.prefix.task);
        text.inputEl.onblur = (e) => __async(this, null, function* () {
          const inputedValue = e.target.value;
          this.plugin.settings.prefix.task = inputedValue;
          this.display();
          yield this.plugin.saveSettings();
          this.callRefreshView(false);
        });
      });
      new import_obsidian10.Setting(containerEl).setName("Add checkbox text to prefix").setDesc("add [ ] or [x]").setClass("setting-indent").addToggle((toggle) => {
        toggle.setValue(this.plugin.settings.addCheckboxText).onChange((value) => __async(this, null, function* () {
          this.plugin.settings.addCheckboxText = value;
          this.display();
          yield this.plugin.saveSettings();
          this.callRefreshView(false);
        }));
      });
      this.containerEl.createEl("p", {
        text: "Completed tasks",
        cls: "setting-category"
      });
      new import_obsidian10.Setting(containerEl).setName("Icon").setClass("setting-indent").addDropdown((dropdown) => {
        dropdown.addOption("none", "none").addOption("check-square", "check-square").addOption("check-circle", "check-circle").addOption("check", "check").addOption("custom", "custom").setValue(this.plugin.settings.icon.taskDone).onChange((value) => __async(this, null, function* () {
          this.plugin.settings.icon.taskDone = value;
          this.display();
          yield this.plugin.saveSettings();
          this.callRefreshView(false);
        }));
      });
      if (this.plugin.settings.icon.taskDone == "custom") {
        new import_obsidian10.Setting(containerEl).setName("Custom icon").setClass("setting-indent-2").setDesc("enter Lucide Icon name").addText((text) => {
          text.inputEl.setAttr("type", "string");
          text.setPlaceholder(DEFAULT_SETTINGS.customIcon.taskDone).setValue(this.plugin.settings.customIcon.taskDone);
          text.inputEl.onblur = (e) => __async(this, null, function* () {
            const inputedValue = e.target.value;
            this.plugin.settings.customIcon.taskDone = inputedValue;
            yield this.plugin.saveSettings();
            this.callRefreshView(false);
          });
        });
      }
      new import_obsidian10.Setting(containerEl).setName("Prefix").setClass("setting-indent").addText((text) => {
        text.inputEl.setAttr("type", "string");
        text.setPlaceholder(DEFAULT_SETTINGS.prefix.taskDone).setValue(this.plugin.settings.prefix.taskDone);
        text.inputEl.onblur = (e) => __async(this, null, function* () {
          const inputedValue = e.target.value;
          this.plugin.settings.prefix.taskDone = inputedValue;
          this.display();
          yield this.plugin.saveSettings();
          this.callRefreshView(false);
        });
      });
    }
    if (this.plugin.settings.showBacklinks) {
      this.containerEl.createEl("p", {
        text: "Backlinks",
        cls: "setting-category"
      });
      new import_obsidian10.Setting(containerEl).setName("Icon").setClass("setting-indent").addDropdown((dropdown) => {
        dropdown.addOption("none", "none").addOption("links-coming-in", "links-coming-in").addOption("file", "file").addOption("corner-up-left", "corner-up-left").addOption("custom", "custom").setValue(this.plugin.settings.icon.backlink).onChange((value) => __async(this, null, function* () {
          this.plugin.settings.icon.backlink = value;
          this.display();
          yield this.plugin.saveSettings();
          this.callRefreshView(false);
        }));
      });
      if (this.plugin.settings.icon.backlink == "custom") {
        new import_obsidian10.Setting(containerEl).setName("Custom icon").setClass("setting-indent-2").setDesc("enter Lucide Icon name").addText((text) => {
          text.inputEl.setAttr("type", "string");
          text.setPlaceholder(DEFAULT_SETTINGS.customIcon.backlink).setValue(this.plugin.settings.customIcon.backlink);
          text.inputEl.onblur = (e) => __async(this, null, function* () {
            const inputedValue = e.target.value;
            this.plugin.settings.customIcon.backlink = inputedValue;
            yield this.plugin.saveSettings();
            this.callRefreshView(false);
          });
        });
      }
      new import_obsidian10.Setting(containerEl).setName("Prefix").setClass("setting-indent").addText((text) => {
        text.inputEl.setAttr("type", "string");
        text.setPlaceholder(DEFAULT_SETTINGS.prefix.backlink).setValue(this.plugin.settings.prefix.backlink);
        text.inputEl.onblur = (e) => __async(this, null, function* () {
          const inputedValue = e.target.value;
          this.plugin.settings.prefix.backlink = inputedValue;
          this.display();
          yield this.plugin.saveSettings();
          this.callRefreshView(false);
        });
      });
    }
    this.containerEl.createEl("h4", {
      text: "Others",
      cls: "setting-category"
    });
    new import_obsidian10.Setting(containerEl).setName("Maximum number of files to read").setDesc("To avoid overloading, files that exceed this number will be initially collapsed. (default = 50)").addText((text) => {
      text.inputEl.setAttr("type", "number");
      text.setPlaceholder(String(DEFAULT_SETTINGS.readLimit)).setValue(String(this.plugin.settings.readLimit));
      text.inputEl.onblur = (e) => __async(this, null, function* () {
        let parsed = parseInt(e.target.value, 10);
        if (parsed <= 0) {
          parsed = DEFAULT_SETTINGS.readLimit;
        }
        this.plugin.settings.readLimit = parsed;
        yield this.plugin.saveSettings();
        this.callRefreshView(true);
      });
    });
    new import_obsidian10.Setting(containerEl).setName("Maximum number of files to process").setDesc("To avoid overloading, if the number of files to be displayed exceeds this number, all files will be initially collapsed. (default = 100)").addText((text) => {
      text.inputEl.setAttr("type", "number");
      text.setPlaceholder(String(DEFAULT_SETTINGS.processLimit)).setValue(String(this.plugin.settings.processLimit));
      text.inputEl.onblur = (e) => __async(this, null, function* () {
        let parsed = parseInt(e.target.value, 10);
        if (parsed <= 0) {
          parsed = DEFAULT_SETTINGS.processLimit;
        }
        this.plugin.settings.processLimit = parsed;
        yield this.plugin.saveSettings();
        this.callRefreshView(true);
      });
    });
    new import_obsidian10.Setting(containerEl).setName("Startup delay time(ms)").setDesc("Wait for the specified time at startup. (default = 300)").addText((text) => {
      text.inputEl.setAttr("type", "number");
      text.setPlaceholder(String(DEFAULT_SETTINGS.bootDelayTime)).setValue(String(this.plugin.settings.bootDelayTime));
      text.inputEl.onblur = (e) => __async(this, null, function* () {
        let parsed = parseInt(e.target.value, 10);
        if (parsed <= 0 || parsed >= 2e5) {
          parsed = DEFAULT_SETTINGS.bootDelayTime;
        }
        this.plugin.settings.bootDelayTime = parsed;
        yield this.plugin.saveSettings();
      });
    });
    new import_obsidian10.Setting(containerEl).setName("show debug information").setDesc("display debug information in the console").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showDebugInfo).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.showDebugInfo = value;
        this.display();
        yield this.plugin.saveSettings();
      }));
    });
  }
  callRefreshView(reload) {
    if (this.plugin.view) {
      this.plugin.view.refreshView(reload, reload);
    }
    if (this.plugin.folderview) {
      this.plugin.folderview.refreshView(reload, reload);
    }
  }
};

// src/folderView.ts
var import_obsidian11 = __toModule(require("obsidian"));
var import_obsidian12 = __toModule(require("obsidian"));
var MultipleNotesOutlineFolderViewType = "multiple-notes-outline-folder-view";
var MultipleNotesOutlineFolderView = class extends import_obsidian12.ItemView {
  constructor(leaf, plugin, settings) {
    super(leaf);
    this.targetFiles = {};
    this.fileStatus = {};
    this.fileInfo = {};
    this.outlineData = {};
    this.fileOrder = {};
    this.flagChanged = false;
    this.flagRegetTarget = false;
    this.flagSaveSettings = false;
    this.extractMode = false;
    this.extractTask = false;
    this.collapseAll = false;
    this.hasMainChanged = false;
    this.filecount = 0;
    this.changedFiles = [];
    this.viewType = "folder";
    this.pinnedMode = false;
    this.isDataviewEnabled = false;
    this.plugin = plugin;
    this.settings = settings;
  }
  getViewType() {
    return MultipleNotesOutlineFolderViewType;
  }
  getDisplayText() {
    return "MNO - folder view";
  }
  getIcon() {
    return "folders";
  }
  onOpen() {
    return __async(this, null, function* () {
      yield this.initView();
    });
  }
  updateSettings() {
    this.settings = this.plugin.settings;
  }
  onClose() {
    return __async(this, null, function* () {
    });
  }
  initView() {
    return __async(this, null, function* () {
      var _a, _b, _c, _d;
      yield this.bootDelay();
      checkRelatedFiles(this.app, this.settings);
      checkFavAndRecentFiles(this.app, this.settings, this.viewType);
      this.collapseAll = this.settings.collapseAllAtStartup;
      this.theme = getTheme();
      setNoteTitleBackgroundColor(this.theme, this.settings);
      this.activeFile = this.app.workspace.getActiveFile();
      if (this.activeFile) {
        if (this.settings.openRecentAtStartup.folder && this.app.vault.getAbstractFileByPath((_a = this.settings.recent.folder) == null ? void 0 : _a[0]) instanceof import_obsidian11.TFolder) {
          this.targetFolder = this.app.vault.getAbstractFileByPath((_b = this.settings.recent.folder) == null ? void 0 : _b[0]);
        } else {
          this.targetFolder = this.activeFile.parent;
        }
      } else {
        if (this.app.vault.getAbstractFileByPath((_c = this.settings.recent.folder) == null ? void 0 : _c[0]) instanceof import_obsidian11.TFolder) {
          this.targetFolder = this.app.vault.getAbstractFileByPath((_d = this.settings.recent.folder) == null ? void 0 : _d[0]);
        } else {
          this.targetFolder = null;
        }
      }
      this.refreshView(true, true);
      const debouncerRequestRefresh = (0, import_obsidian11.debounce)(this.autoRefresh, 3e3, true);
      this.flagChanged = false;
      this.flagRegetTarget = false;
      this.registerEvent(this.app.metadataCache.on("changed", (file) => {
        for (const folder in this.targetFiles) {
          if (this.targetFiles[folder].includes(file)) {
            if (!this.changedFiles.includes(file)) {
              this.changedFiles.push(file);
            }
            this.flagChanged = true;
            debouncerRequestRefresh.call(this);
            break;
          }
        }
      }));
      this.registerEvent(this.app.vault.on("create", (file) => {
        this.flagRegetTarget = true;
        debouncerRequestRefresh.call(this);
      }));
      this.registerEvent(this.app.vault.on("delete", (file) => {
        const changedRelatedFiles = handleDeleteRelatedFiles(file, this.settings);
        if (changedRelatedFiles) {
          this.flagSaveSettings = true;
        }
        const changedFavAndRecent = handleDeleteFavAndRecentFiles(file, this.settings);
        if (changedFavAndRecent) {
          this.flagSaveSettings = true;
        }
        this.flagRegetTarget = true;
        debouncerRequestRefresh.call(this);
      }));
      this.registerEvent(this.app.vault.on("rename", (file, oldPath) => {
        const changedRelatedFiles = handleRenameRelatedFiles(file, oldPath, this.settings);
        if (changedRelatedFiles) {
          this.flagSaveSettings = true;
        }
        const changedFavAndRecent = handleRenameFavAndRecentFiles(file, oldPath, this.settings);
        if (changedFavAndRecent) {
          this.flagSaveSettings = true;
        }
        this.flagRegetTarget = true;
        debouncerRequestRefresh.call(this);
      }));
      this.registerEvent(this.app.workspace.on("css-change", (e) => {
        const newTheme = getTheme();
        if (newTheme !== this.theme) {
          this.theme = newTheme;
          setNoteTitleBackgroundColor(this.theme, this.settings);
        }
      }));
    });
  }
  bootDelay() {
    return __async(this, null, function* () {
      return new Promise((resolve) => {
        setTimeout(resolve, this.settings.bootDelayTime);
      });
    });
  }
  autoRefresh() {
    return __async(this, null, function* () {
      if (!(this.flagChanged || this.flagRegetTarget || this.flagSaveSettings)) {
        return;
      }
      if (this.flagChanged && !this.flagRegetTarget) {
        for (let i = 0; i < this.changedFiles.length; i++) {
          for (const folder in this.targetFiles) {
            const index = this.targetFiles[folder].indexOf(this.changedFiles[i]);
            if (index < 0) {
              continue;
            }
            this.fileInfo[folder][index] = yield getFileInfo(this.app, this.targetFiles[folder][index], this.settings, false, this.isDataviewEnabled);
            const newData = yield getOutline(this.app, this.targetFiles[folder][index], this.fileStatus[folder][index], this.fileInfo[folder][index], this.settings);
            if (newData) {
              this.outlineData[folder][index] = newData;
              this.fileStatus[folder][index].outlineReady = true;
            }
            const updateNoteChildrenEl = document.getElementById("MNO" + this.viewType + this.targetFiles[folder][index].path);
            updateNoteChildrenEl.empty();
            constructOutlineDOM.call(this, this.targetFiles[folder][index], this.fileInfo[folder][index], this.outlineData[folder][index], updateNoteChildrenEl, "folder");
          }
        }
      }
      if (this.flagSaveSettings) {
        yield this.plugin.saveSettings();
      }
      if (this.flagRegetTarget) {
        this.refreshView(this.flagRegetTarget, this.flagRegetTarget);
      }
      this.changedFiles = [];
      this.flagRegetTarget = false;
      this.flagChanged = false;
      this.flagSaveSettings = false;
    });
  }
  refreshView(flagGetTarget, flagGetOutline) {
    return __async(this, null, function* () {
      const startTime = performance.now();
      this.isDataviewEnabled = checkDataview(this.app);
      const containerEl = document.getElementById("MNOfolderview-listcontainer");
      const previousY = (containerEl == null ? void 0 : containerEl.scrollTop) ? containerEl.scrollTop : 0;
      if (!this.targetFolder) {
        drawUIFolderView.call(this);
        return;
      }
      this.filecount = 0;
      if (flagGetTarget) {
        if (this.targetFolder) {
          this.clearDatas();
          yield this.processFolder(this.targetFolder);
        }
      }
      const midTime = performance.now();
      if (this.settings.showDebugInfo) {
        console.log("Multiple Notes Outline: time required to get outlines, folder view: ", this.targetFolder.path, midTime - startTime);
      }
      drawUIFolderView.call(this);
      this.drawOutline(previousY);
      const endTime = performance.now();
      if (this.settings.showDebugInfo) {
        console.log("Multiple Notes Outline: time required to draw outlines, folder view: ", this.targetFolder.path, endTime - midTime);
        console.log("Multiple Notes Outline: time required to refresh view, folder view: ", this.targetFolder.path, endTime - startTime);
      }
    });
  }
  processFolder(folder) {
    return __async(this, null, function* () {
      this.targetFiles[folder.path] = folder.children;
      this.fileStatus[folder.path] = initFileStatus(this.targetFiles[folder.path]);
      this.fileOrder[folder.path] = [...Array(this.targetFiles[folder.path].length)].map((_, i) => i);
      sortFileOrder(this.fileOrder[folder.path], this.targetFiles[folder.path], this.fileStatus[folder.path], this.fileInfo[folder.path], this.settings);
      this.fileInfo[folder.path] = [];
      this.outlineData[folder.path] = [];
      if (folder.children.length <= this.settings.processLimit) {
        [this.fileStatus[folder.path], this.fileInfo[folder.path], this.outlineData[folder.path]] = yield this.getOutlines(this.targetFiles[folder.path], this.fileStatus[folder.path]);
      }
    });
  }
  getOutlines(files, status) {
    return __async(this, null, function* () {
      const fileInfo = [];
      const outlineData = [];
      for (let i = 0; i < files.length; i++) {
        if (checkFlag(this.targetFolder, files[i], "top", this.settings) == true) {
          status[i].isTop = true;
        }
        if (status[i].isFolder) {
          fileInfo.push(void 0);
          outlineData.push(void 0);
          if (!this.settings.collapseFolder) {
            yield this.processFolder(files[i]);
            status[i].outlineReady = true;
          }
        } else {
          if (this.filecount < this.settings.readLimit || status[i].isTop) {
            const info = yield getFileInfo(this.app, files[i], this.settings, false, this.isDataviewEnabled);
            fileInfo.push(info);
            const data = yield getOutline(this.app, files[i], status[i], info, this.settings);
            if (data) {
              outlineData.push(data);
              status[i].outlineReady = true;
            } else {
              outlineData.push(void 0);
            }
          } else {
            fileInfo.push(void 0);
            outlineData.push(void 0);
          }
          this.filecount++;
        }
      }
      return [status, fileInfo, outlineData];
    });
  }
  drawOutline(previousY) {
    const containerEl = createDiv("nav-files-container node-insert-event");
    const rootEl = containerEl.createDiv("tree-item nav-folder mod-root");
    const rootChildrenEl = rootEl.createDiv("tree-item-children nav-folder-children");
    containerEl.id = "MNOfolderview-listcontainer";
    const folderEl = rootChildrenEl.createDiv("tree-itme nav-folder");
    const folderTitleEl = folderEl.createDiv("tree-item-self is-clickable mod-collapsible nav-folder-title is-targetfolder");
    folderTitleEl.createDiv("tree-item-inner nav-folder-title-content").setText(this.targetFolder.path);
    folderTitleEl.addEventListener("contextmenu", (event) => {
      const menu = new import_obsidian11.Menu();
      if (this.settings.favorite.folder.includes(this.targetFolder.path)) {
        menu.addItem((item) => item.setTitle("MNO: Remove from favorites").setIcon("bookmark-minus").onClick(() => __async(this, null, function* () {
          deleteFavAndRecent.call(this, this.targetFolder.path, "folder", "favorite");
          yield this.plugin.saveSettings();
        })));
      } else {
        menu.addItem((item) => item.setTitle("MNO: Add to favorites").setIcon("bookmark-plus").onClick(() => __async(this, null, function* () {
          updateFavAndRecent.call(this, this.targetFolder.path, "folder", "favorite");
          yield this.plugin.saveSettings();
        })));
      }
      menu.showAtMouseEvent(event);
    });
    const folderChildrenEl = folderEl.createDiv("tree-item-children nav-folder-children");
    const categoryAOTEl = folderChildrenEl.createDiv("tree-item nav-folder");
    const categoryMainEl = folderChildrenEl.createDiv("tree-item nav-folder");
    constructNoteDOM.call(this, this.targetFiles[this.targetFolder.path], this.fileStatus[this.targetFolder.path], this.fileInfo[this.targetFolder.path], this.outlineData[this.targetFolder.path], categoryMainEl, "folder", categoryAOTEl, this.targetFolder, this.fileOrder[this.targetFolder.path]);
    this.contentEl.appendChild(containerEl);
    if (this.hasMainChanged == false && previousY != 0) {
      containerEl.scrollTop = previousY;
    }
    this.hasMainChanged = false;
  }
  clearDatas() {
    this.targetFiles = {};
    this.fileStatus = {};
    this.fileInfo = {};
    this.outlineData = {};
    this.fileOrder = {};
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  autoupdateFileView: true,
  suspendUpdateByClickingView: true,
  autoupdateFolderView: false,
  showFiles: {
    main: true,
    outgoing: true,
    backlink: true
  },
  showElements: {
    heading: true,
    link: true,
    tag: true,
    listItems: true,
    task: true
  },
  maxHeadingLevel: 6,
  hideLinksBetweenRelatedFiles: "none",
  allRootItems: false,
  allTasks: true,
  taskOnly: false,
  hideCompletedTasks: false,
  displayFileInfo: "lines",
  viewPosition: "right",
  inlinePreview: true,
  tooltipPreview: true,
  tooltipPreviewDirection: "left",
  wordsToExtract: "",
  icon: {
    heading: "none",
    link: "link",
    tag: "tag",
    listItems: "list",
    note: "file",
    task: "square",
    taskDone: "check-square",
    backlink: "links-coming-in"
  },
  customIcon: {
    heading: "hash",
    link: "link",
    tag: "tag",
    listItems: "list",
    note: "file",
    task: "square",
    taskDone: "check-square",
    backlink: "links-coming-in"
  },
  indent: {
    heading: true,
    link: true,
    tag: true,
    listItems: true
  },
  indentFollowHeading: 2,
  prefix: {
    heading: "",
    link: "",
    tag: "",
    listItems: "",
    task: "",
    taskDone: "",
    backlink: ""
  },
  repeatHeadingPrefix: "none",
  addCheckboxText: false,
  hideDuplicated: true,
  readLimit: 50,
  processLimit: 100,
  noteTitleBackgroundColor: "accent",
  customNoteTitleBackgroundColor: {
    light: "#BEBEBE",
    dark: "#4E4E4E"
  },
  customNoteTitleBackgroundColorHover: {
    light: "#AEAEAE",
    dark: "#5E5E5E"
  },
  tagsAOT: [],
  showBacklinks: true,
  relatedFiles: {},
  openAtStartup: {
    file: false,
    folder: false
  },
  collapseFolder: true,
  sortType: "alphabetAscending",
  showDebugInfo: false,
  collapseAllAtStartup: false,
  showPropertyLinks: true,
  recent: {
    file: [],
    folder: []
  },
  favorite: {
    file: [],
    folder: []
  },
  numOfRecentFiles: 30,
  pinAfterJump: true,
  openRecentAtStartup: {
    file: false,
    folder: false
  },
  popoutSize: {
    width: 600,
    height: 800
  },
  popoutAlwaysOnTop: false,
  openLinkByClick: false,
  hideMinor2hopLink: false,
  dispListCallouts: true,
  saveRecentView: true,
  wrapLine: false,
  bootDelayTime: 300
};
var FILE_TITLE_BACKGROUND_COLOR = {
  default: {
    light: "#F6F6F6",
    dark: "#262626"
  },
  accent: {
    light: "#E3E3E3",
    dark: "#363636"
  }
};
var FILE_TITLE_BACKGROUND_COLOR_HOVER = {
  default: {
    light: "#E3E3E3",
    dark: "#363636"
  },
  accent: {
    light: "#D3D3D3",
    dark: "#464646"
  }
};
var LIST_CALLOUT_DEFAULT = [
  {
    color: "255, 214, 0",
    char: "&"
  },
  {
    color: "255, 145, 0",
    char: "?"
  },
  {
    color: "255, 23, 68",
    char: "!",
    icon: "lucide-alert-circle"
  },
  {
    color: "124, 77, 255",
    char: "~",
    icon: "lucide-crosshair"
  },
  {
    color: "0, 184, 212",
    char: "@"
  },
  {
    color: "0, 200, 83",
    char: "$"
  },
  {
    color: "158, 158, 158",
    char: "%"
  }
];
var MultipleNotesOutlinePlugin3 = class extends import_obsidian13.Plugin {
  constructor() {
    super(...arguments);
    this.checkFileView = (activateView) => __async(this, null, function* () {
      let [leaf] = this.app.workspace.getLeavesOfType(MultipleNotesOutlineViewType);
      if (!leaf) {
        switch (this.settings.viewPosition) {
          case "right":
            leaf = this.app.workspace.getRightLeaf(false);
            break;
          case "left":
            leaf = this.app.workspace.getLeftLeaf(false);
            break;
          case "tab":
            leaf = this.app.workspace.getLeaf("tab");
            break;
          case "split":
            leaf = this.app.workspace.getLeaf("split");
            break;
          case "popout":
            leaf = this.app.workspace.getLeaf("window");
            break;
        }
        yield leaf.setViewState({ type: MultipleNotesOutlineViewType });
      }
      if (activateView) {
        this.app.workspace.revealLeaf(leaf);
      }
    });
    this.checkFolderView = (activateView) => __async(this, null, function* () {
      let [leaf] = this.app.workspace.getLeavesOfType(MultipleNotesOutlineFolderViewType);
      if (!leaf) {
        switch (this.settings.viewPosition) {
          case "right":
            leaf = this.app.workspace.getRightLeaf(false);
            break;
          case "left":
            leaf = this.app.workspace.getLeftLeaf(false);
            break;
          case "tab":
            leaf = this.app.workspace.getLeaf("tab");
            break;
          case "split":
            leaf = this.app.workspace.getLeaf("split");
            break;
          case "popout":
            leaf = this.app.workspace.getLeaf("window");
            break;
        }
        yield leaf.setViewState({ type: MultipleNotesOutlineFolderViewType });
      }
      if (activateView) {
        this.app.workspace.revealLeaf(leaf);
      }
    });
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.registerView(MultipleNotesOutlineViewType, (leaf) => this.view = new MultipleNotesOutlineView(leaf, this, this.settings));
      this.registerView(MultipleNotesOutlineFolderViewType, (leaf) => this.folderview = new MultipleNotesOutlineFolderView(leaf, this, this.settings));
      this.addCommand({
        id: "open-file-view",
        name: "Open File View",
        callback: () => __async(this, null, function* () {
          this.checkFileView(true);
        })
      });
      this.addCommand({
        id: "open-folder-view",
        name: "Open Folder View",
        callback: () => __async(this, null, function* () {
          this.checkFolderView(true);
        })
      });
      this.addCommand({
        id: "erase-all-fold-AOT-information",
        name: "Erase all folding/always-on-top information",
        callback: () => __async(this, null, function* () {
          const onSubmit = () => __async(this, null, function* () {
            this.settings.relatedFiles = {};
            yield this.saveSettings();
          });
          new ModalConfirm(this.app, this, "Are you sure you want to erase all folding/always-on-top information?", onSubmit).open();
        })
      });
      this.addCommand({
        id: "erase-non-favorite-fold-AOT-information",
        name: "Erase folding/always-on-top information except favorite files/folders",
        callback: () => __async(this, null, function* () {
          const onSubmit = () => __async(this, null, function* () {
            for (const srcFilePath in this.settings.relatedFiles) {
              if (!this.settings.favorite.file.includes(srcFilePath) && !this.settings.favorite.folder.includes(srcFilePath)) {
                delete this.settings.relatedFiles[srcFilePath];
              } else {
              }
            }
            yield this.saveSettings();
          });
          new ModalConfirm(this.app, this, "Are you sure you want to erase folding/always-on-top information of not favorite files/folders?", onSubmit).open();
        })
      });
      this.app.workspace.onLayoutReady(() => __async(this, null, function* () {
        if (this.settings.openAtStartup.file) {
          this.checkFileView(false);
        }
        if (this.settings.openAtStartup.folder) {
          this.checkFolderView(false);
        }
      }));
      this.addSettingTab(new MultipleNotesOutlineSettingTab(this.app, this));
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
      if (!this.settings.icon.hasOwnProperty("backlink")) {
        this.settings.icon.backlink = DEFAULT_SETTINGS.icon.backlink;
        this.settings.customIcon.backlink = DEFAULT_SETTINGS.customIcon.backlink;
        this.settings.prefix.backlink = DEFAULT_SETTINGS.prefix.backlink;
      }
      if (!this.settings.showElements.hasOwnProperty("task")) {
        this.settings.showElements.task = DEFAULT_SETTINGS.showElements.task;
      }
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  onExternalSettingsChange() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.view.updateSettings();
      this.folderview.updateSettings();
    });
  }
};


/* nosourcemap */